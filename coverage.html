
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>podcli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stefanprodan/podinfo/cmd/podcli/check.go (13.2%)</option>
				
				<option value="file1">github.com/stefanprodan/podinfo/cmd/podcli/main.go (0.0%)</option>
				
				<option value="file2">github.com/stefanprodan/podinfo/cmd/podcli/version.go (33.3%)</option>
				
				<option value="file3">github.com/stefanprodan/podinfo/cmd/podcli/ws.go (3.4%)</option>
				
				<option value="file4">github.com/stefanprodan/podinfo/cmd/podinfo/main.go (0.0%)</option>
				
				<option value="file5">github.com/stefanprodan/podinfo/pkg/api/grpc/delay.go (100.0%)</option>
				
				<option value="file6">github.com/stefanprodan/podinfo/pkg/api/grpc/delay/delay.pb.go (0.0%)</option>
				
				<option value="file7">github.com/stefanprodan/podinfo/pkg/api/grpc/delay/delay_grpc.pb.go (0.0%)</option>
				
				<option value="file8">github.com/stefanprodan/podinfo/pkg/api/grpc/echo.go (100.0%)</option>
				
				<option value="file9">github.com/stefanprodan/podinfo/pkg/api/grpc/echo/echo.pb.go (0.0%)</option>
				
				<option value="file10">github.com/stefanprodan/podinfo/pkg/api/grpc/echo/echo_grpc.pb.go (0.0%)</option>
				
				<option value="file11">github.com/stefanprodan/podinfo/pkg/api/grpc/env.go (100.0%)</option>
				
				<option value="file12">github.com/stefanprodan/podinfo/pkg/api/grpc/env/env.pb.go (0.0%)</option>
				
				<option value="file13">github.com/stefanprodan/podinfo/pkg/api/grpc/env/env_grpc.pb.go (0.0%)</option>
				
				<option value="file14">github.com/stefanprodan/podinfo/pkg/api/grpc/headers.go (85.7%)</option>
				
				<option value="file15">github.com/stefanprodan/podinfo/pkg/api/grpc/headers/headers.pb.go (0.0%)</option>
				
				<option value="file16">github.com/stefanprodan/podinfo/pkg/api/grpc/headers/headers_grpc.pb.go (0.0%)</option>
				
				<option value="file17">github.com/stefanprodan/podinfo/pkg/api/grpc/info.go (80.0%)</option>
				
				<option value="file18">github.com/stefanprodan/podinfo/pkg/api/grpc/info/info.pb.go (0.0%)</option>
				
				<option value="file19">github.com/stefanprodan/podinfo/pkg/api/grpc/info/info_grpc.pb.go (0.0%)</option>
				
				<option value="file20">github.com/stefanprodan/podinfo/pkg/api/grpc/mock_grpc.go (100.0%)</option>
				
				<option value="file21">github.com/stefanprodan/podinfo/pkg/api/grpc/panic.go (0.0%)</option>
				
				<option value="file22">github.com/stefanprodan/podinfo/pkg/api/grpc/panic/panic.pb.go (0.0%)</option>
				
				<option value="file23">github.com/stefanprodan/podinfo/pkg/api/grpc/panic/panic_grpc.pb.go (0.0%)</option>
				
				<option value="file24">github.com/stefanprodan/podinfo/pkg/api/grpc/server.go (0.0%)</option>
				
				<option value="file25">github.com/stefanprodan/podinfo/pkg/api/grpc/status.go (83.3%)</option>
				
				<option value="file26">github.com/stefanprodan/podinfo/pkg/api/grpc/status/status.pb.go (0.0%)</option>
				
				<option value="file27">github.com/stefanprodan/podinfo/pkg/api/grpc/status/status_grpc.pb.go (0.0%)</option>
				
				<option value="file28">github.com/stefanprodan/podinfo/pkg/api/grpc/token.go (25.0%)</option>
				
				<option value="file29">github.com/stefanprodan/podinfo/pkg/api/grpc/token/token.pb.go (0.0%)</option>
				
				<option value="file30">github.com/stefanprodan/podinfo/pkg/api/grpc/token/token_grpc.pb.go (0.0%)</option>
				
				<option value="file31">github.com/stefanprodan/podinfo/pkg/api/grpc/version.go (100.0%)</option>
				
				<option value="file32">github.com/stefanprodan/podinfo/pkg/api/grpc/version/version.pb.go (0.0%)</option>
				
				<option value="file33">github.com/stefanprodan/podinfo/pkg/api/grpc/version/version_grpc.pb.go (0.0%)</option>
				
				<option value="file34">github.com/stefanprodan/podinfo/pkg/api/http/cache.go (0.0%)</option>
				
				<option value="file35">github.com/stefanprodan/podinfo/pkg/api/http/chunked.go (82.4%)</option>
				
				<option value="file36">github.com/stefanprodan/podinfo/pkg/api/http/configs.go (0.0%)</option>
				
				<option value="file37">github.com/stefanprodan/podinfo/pkg/api/http/delay.go (28.1%)</option>
				
				<option value="file38">github.com/stefanprodan/podinfo/pkg/api/http/docs/docs.go (0.0%)</option>
				
				<option value="file39">github.com/stefanprodan/podinfo/pkg/api/http/echo.go (18.5%)</option>
				
				<option value="file40">github.com/stefanprodan/podinfo/pkg/api/http/echows.go (0.0%)</option>
				
				<option value="file41">github.com/stefanprodan/podinfo/pkg/api/http/env.go (0.0%)</option>
				
				<option value="file42">github.com/stefanprodan/podinfo/pkg/api/http/headers.go (100.0%)</option>
				
				<option value="file43">github.com/stefanprodan/podinfo/pkg/api/http/health.go (33.3%)</option>
				
				<option value="file44">github.com/stefanprodan/podinfo/pkg/api/http/http.go (34.9%)</option>
				
				<option value="file45">github.com/stefanprodan/podinfo/pkg/api/http/index.go (0.0%)</option>
				
				<option value="file46">github.com/stefanprodan/podinfo/pkg/api/http/info.go (100.0%)</option>
				
				<option value="file47">github.com/stefanprodan/podinfo/pkg/api/http/logging.go (0.0%)</option>
				
				<option value="file48">github.com/stefanprodan/podinfo/pkg/api/http/metrics.go (0.0%)</option>
				
				<option value="file49">github.com/stefanprodan/podinfo/pkg/api/http/mock.go (100.0%)</option>
				
				<option value="file50">github.com/stefanprodan/podinfo/pkg/api/http/panic.go (0.0%)</option>
				
				<option value="file51">github.com/stefanprodan/podinfo/pkg/api/http/server.go (0.0%)</option>
				
				<option value="file52">github.com/stefanprodan/podinfo/pkg/api/http/status.go (75.0%)</option>
				
				<option value="file53">github.com/stefanprodan/podinfo/pkg/api/http/store.go (0.0%)</option>
				
				<option value="file54">github.com/stefanprodan/podinfo/pkg/api/http/token.go (34.1%)</option>
				
				<option value="file55">github.com/stefanprodan/podinfo/pkg/api/http/tracer.go (0.0%)</option>
				
				<option value="file56">github.com/stefanprodan/podinfo/pkg/api/http/version.go (100.0%)</option>
				
				<option value="file57">github.com/stefanprodan/podinfo/pkg/fscache/fscache.go (79.1%)</option>
				
				<option value="file58">github.com/stefanprodan/podinfo/pkg/signals/shutdown.go (0.0%)</option>
				
				<option value="file59">github.com/stefanprodan/podinfo/pkg/signals/signal.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/status"
)

var (
        retryCount      int
        retryDelay      time.Duration
        method          string
        body            string
        timeout         time.Duration
        grpcServiceName string
)

var checkCmd = &amp;cobra.Command{
        Use:   `check`,
        Short: "Health check commands",
        Long:  "Commands for running health checks",
}

var checkUrlCmd = &amp;cobra.Command{
        Use:     `http [address]`,
        Short:   "HTTP(S) health check",
        Example: `  check http https://httpbin.org/anything --method=POST --retry=2 --delay=2s --timeout=3s --body='{"test"=1}'`,
        RunE:    runCheck,
}

var checkTcpCmd = &amp;cobra.Command{
        Use:     `tcp [address]`,
        Short:   "TCP health check",
        Example: `  check tcp httpbin.org:443 --retry=1 --delay=2s --timeout=2s`,
        RunE:    runCheckTCP,
}

var checkCertCmd = &amp;cobra.Command{
        Use:     `cert [address]`,
        Short:   "SSL/TLS certificate validity check",
        Example: `  check cert httpbin.org`,
        RunE:    runCheckCert,
}

var checkgRPCCmd = &amp;cobra.Command{
        Use:     `grpc [address]`,
        Short:   "gRPC health check",
        Example: `  check grpc localhost:8080 --service=podinfo --retry=1 --delay=2s --timeout=2s`,
        RunE:    runCheckgPRC,
}

func init() <span class="cov8" title="1">{
        checkUrlCmd.Flags().StringVar(&amp;method, "method", "GET", "HTTP method")
        checkUrlCmd.Flags().StringVar(&amp;body, "body", "", "HTTP POST/PUT content")
        checkUrlCmd.Flags().IntVar(&amp;retryCount, "retry", 0, "times to retry the HTTP call")
        checkUrlCmd.Flags().DurationVar(&amp;retryDelay, "delay", 1*time.Second, "wait duration between retries")
        checkUrlCmd.Flags().DurationVar(&amp;timeout, "timeout", 5*time.Second, "timeout")
        checkCmd.AddCommand(checkUrlCmd)

        checkTcpCmd.Flags().IntVar(&amp;retryCount, "retry", 0, "times to retry the TCP check")
        checkTcpCmd.Flags().DurationVar(&amp;retryDelay, "delay", 1*time.Second, "wait duration between retries")
        checkTcpCmd.Flags().DurationVar(&amp;timeout, "timeout", 5*time.Second, "timeout")
        checkCmd.AddCommand(checkTcpCmd)

        checkgRPCCmd.Flags().IntVar(&amp;retryCount, "retry", 0, "times to retry the TCP check")
        checkgRPCCmd.Flags().DurationVar(&amp;retryDelay, "delay", 1*time.Second, "wait duration between retries")
        checkgRPCCmd.Flags().DurationVar(&amp;timeout, "timeout", 5*time.Second, "timeout")
        checkgRPCCmd.Flags().StringVar(&amp;grpcServiceName, "service", "", "gRPC service name")
        checkCmd.AddCommand(checkgRPCCmd)

        checkCmd.AddCommand(checkCertCmd)

        rootCmd.AddCommand(checkCmd)
}</span>

func runCheck(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if retryCount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--retry is required")
        }</span>
        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("address is required! example: check http https://httpbin.org")
        }</span>

        <span class="cov0" title="0">address := args[0]
        if !strings.HasPrefix(address, "http://") &amp;&amp; !strings.HasPrefix(address, "https://") </span><span class="cov0" title="0">{
                address = fmt.Sprintf("http://%s", address)
        }</span>

        <span class="cov0" title="0">for n := 0; n &lt;= retryCount; n++ </span><span class="cov0" title="0">{
                if n != 1 </span><span class="cov0" title="0">{
                        time.Sleep(retryDelay)
                }</span>

                <span class="cov0" title="0">req, err := http.NewRequest(method, address, bytes.NewBuffer([]byte(body)))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("check failed",
                                zap.String("address", address),
                                zap.Error(err))
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(req.Context(), timeout)
                resp, err := http.DefaultClient.Do(req.WithContext(ctx))
                cancel()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("check failed",
                                zap.String("address", address),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if resp.Body != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                }</span>

                <span class="cov0" title="0">if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                        logger.Info("check succeed",
                                zap.String("address", address),
                                zap.Int("status code", resp.StatusCode),
                                zap.String("response size", fmtContentLength(resp.ContentLength)))
                        os.Exit(0)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("check failed",
                                zap.String("address", address),
                                zap.Int("status code", resp.StatusCode))
                        continue</span>
                }
        }

        <span class="cov0" title="0">os.Exit(1)
        return nil</span>
}

func runCheckTCP(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if retryCount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--retry is required")
        }</span>
        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("address is required! example: check tcp httpbin.org:80")
        }</span>
        <span class="cov0" title="0">address := args[0]

        for n := 0; n &lt;= retryCount; n++ </span><span class="cov0" title="0">{
                if n != 1 </span><span class="cov0" title="0">{
                        time.Sleep(retryDelay)
                }</span>

                <span class="cov0" title="0">conn, err := net.DialTimeout("tcp", address, timeout)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("check failed",
                                zap.String("address", address),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">conn.Close()
                logger.Info("check succeed", zap.String("address", address))
                os.Exit(0)</span>

        }

        <span class="cov0" title="0">os.Exit(1)
        return nil</span>
}

func runCheckCert(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("address is required! example: check cert httpbin.org")
        }</span>
        <span class="cov0" title="0">host := args[0]
        if !strings.HasPrefix(host, "https://") </span><span class="cov0" title="0">{
                host = "https://" + host
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(host)
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("check failed",
                        zap.String("address", host),
                        zap.Error(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">address := u.Hostname() + ":443"
        ipConn, err := net.DialTimeout("tcp", address, 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("check failed",
                        zap.String("address", address),
                        zap.Error(err))
                os.Exit(1)

        }</span>

        <span class="cov0" title="0">defer ipConn.Close()
        conn := tls.Client(ipConn, &amp;tls.Config{
                InsecureSkipVerify: true,
                ServerName:         u.Hostname(),
        })
        if err = conn.Handshake(); err != nil </span><span class="cov0" title="0">{
                logger.Info("check failed",
                        zap.String("address", address),
                        zap.Error(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">defer conn.Close()
        addr := conn.RemoteAddr()
        _, _, err = net.SplitHostPort(addr.String())
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("check failed",
                        zap.String("address", address),
                        zap.Error(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cert := conn.ConnectionState().PeerCertificates[0]

        timeNow := time.Now()
        if timeNow.After(cert.NotAfter) </span><span class="cov0" title="0">{
                logger.Info("check failed",
                        zap.String("address", address),
                        zap.String("issuer", cert.Issuer.CommonName),
                        zap.String("subject", cert.Subject.CommonName),
                        zap.Time("expired", cert.NotAfter))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("check succeed",
                zap.String("address", address),
                zap.String("issuer", cert.Issuer.CommonName),
                zap.String("subject", cert.Subject.CommonName),
                zap.Time("notAfter", cert.NotAfter),
                zap.Time("notBefore", cert.NotBefore))

        return nil</span>
}

func fmtContentLength(b int64) string <span class="cov0" title="0">{
        const unit = 1000
        if b &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", b)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := b / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "kMGTPE"[exp])</span>
}

func runCheckgPRC(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if retryCount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--retry is required")
        }</span>
        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("address is required! example: check grpc localhost:8080")
        }</span>
        <span class="cov0" title="0">address := args[0]

        for n := 0; n &lt;= retryCount; n++ </span><span class="cov0" title="0">{
                if n != 1 </span><span class="cov0" title="0">{
                        time.Sleep(retryDelay)
                }</span>

                <span class="cov0" title="0">conn, err := grpc.Dial(address, grpc.WithInsecure())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("check failed",
                                zap.String("address", address),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
                resp, err := grpc_health_v1.NewHealthClient(conn).Check(ctx, &amp;grpc_health_v1.HealthCheckRequest{
                        Service: grpcServiceName,
                })
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        if stat, ok := status.FromError(err); ok &amp;&amp; stat.Code() == codes.Unimplemented </span><span class="cov0" title="0">{
                                logger.Info("gPRC health protocol not implemented")
                                os.Exit(1)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info("check failed",
                                        zap.String("address", address),
                                        zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">conn.Close()
                logger.Info("check succeed",
                        zap.String("status", resp.GetStatus().String()))
                os.Exit(0)</span>

        }

        <span class="cov0" title="0">os.Exit(1)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

var rootCmd = &amp;cobra.Command{
        Use:   "podcli",
        Short: "podinfo command line",
        Long: `
podinfo command line utilities`,
}

var (
        logger *zap.Logger
)

func main() <span class="cov0" title="0">{

        var err error
        logger, err = zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("can't initialize zap logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        rootCmd.SetArgs(os.Args[1:])
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                e := err.Error()
                fmt.Println(strings.ToUpper(e[:1]) + e[1:])
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/stefanprodan/podinfo/pkg/version"
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>

var versionCmd = &amp;cobra.Command{
        Use:   `version`,
        Short: "Prints podcli version",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println(version.VERSION)
                return nil
        }</span>,
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/hex"
        "fmt"
        "net/http"
        "net/url"
        "os"
        "regexp"
        "strings"

        "github.com/chzyer/readline"
        "github.com/fatih/color"
        "github.com/gorilla/websocket"
        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

var origin string

func init() <span class="cov8" title="1">{
        wsCmd.Flags().StringVarP(&amp;origin, "origin", "o", "", "websocket origin")
        rootCmd.AddCommand(wsCmd)
}</span>

var wsCmd = &amp;cobra.Command{
        Use:     `ws [address]`,
        Short:   "Websocket client",
        Example: `  ws localhost:9898/ws/echo`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("address is required")
                }</span>

                <span class="cov0" title="0">address := args[0]
                if !strings.HasPrefix(address, "ws://") &amp;&amp; !strings.HasPrefix(address, "wss://") </span><span class="cov0" title="0">{
                        address = fmt.Sprintf("ws://%s", address)
                }</span>

                <span class="cov0" title="0">dest, err := url.Parse(address)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if origin != "" </span>{<span class="cov0" title="0">
                }</span> else<span class="cov0" title="0"> {
                        originURL := *dest
                        if dest.Scheme == "wss" </span><span class="cov0" title="0">{
                                originURL.Scheme = "https"
                        }</span> else<span class="cov0" title="0"> {
                                originURL.Scheme = "http"
                        }</span>
                        <span class="cov0" title="0">origin = originURL.String()</span>
                }

                <span class="cov0" title="0">err = connect(dest.String(), origin, &amp;readline.Config{
                        Prompt: "&gt; ",
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("websocket closed", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
}

type session struct {
        ws      *websocket.Conn
        rl      *readline.Instance
        errChan chan error
}

func connect(url, origin string, rlConf *readline.Config) error <span class="cov0" title="0">{
        headers := make(http.Header)
        headers.Add("Origin", origin)

        ws, _, err := websocket.DefaultDialer.Dial(url, headers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rl, err := readline.NewEx(rlConf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rl.Close()

        sess := &amp;session{
                ws:      ws,
                rl:      rl,
                errChan: make(chan error),
        }

        go sess.readConsole()
        go sess.readWebsocket()

        return &lt;-sess.errChan</span>
}

func (s *session) readConsole() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                line, err := s.rl.Readline()
                if err != nil </span><span class="cov0" title="0">{
                        s.errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">err = s.ws.WriteMessage(websocket.TextMessage, []byte(line))
                if err != nil </span><span class="cov0" title="0">{
                        s.errChan &lt;- err
                        return
                }</span>
        }
}

func bytesToFormattedHex(bytes []byte) string <span class="cov0" title="0">{
        text := hex.EncodeToString(bytes)
        return regexp.MustCompile("(..)").ReplaceAllString(text, "$1 ")
}</span>

func (s *session) readWebsocket() <span class="cov0" title="0">{
        rxSprintf := color.New(color.FgGreen).SprintfFunc()

        for </span><span class="cov0" title="0">{
                msgType, buf, err := s.ws.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprint(s.rl.Stdout(), rxSprintf("&lt; %s\n", err.Error()))
                        os.Exit(1)
                        return
                }</span>

                <span class="cov0" title="0">var text string
                switch msgType </span>{
                case websocket.TextMessage:<span class="cov0" title="0">
                        text = string(buf)</span>
                case websocket.BinaryMessage:<span class="cov0" title="0">
                        text = bytesToFormattedHex(buf)</span>
                default:<span class="cov0" title="0">
                        s.errChan &lt;- fmt.Errorf("unknown websocket frame type: %d", msgType)
                        return</span>
                }

                <span class="cov0" title="0">fmt.Fprint(s.rl.Stdout(), rxSprintf("&lt; %s\n", text))</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/spf13/pflag"
        "github.com/spf13/viper"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/stefanprodan/podinfo/pkg/api/grpc"
        "github.com/stefanprodan/podinfo/pkg/api/http"
        "github.com/stefanprodan/podinfo/pkg/signals"
        "github.com/stefanprodan/podinfo/pkg/version"
        go_grpc "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        // flags definition
        fs := pflag.NewFlagSet("default", pflag.ContinueOnError)
        fs.String("host", "", "Host to bind service to")
        fs.Int("port", 9898, "HTTP port to bind service to")
        fs.Int("secure-port", 0, "HTTPS port")
        fs.Int("port-metrics", 0, "metrics port")
        fs.Int("grpc-port", 0, "gRPC port")
        fs.String("grpc-service-name", "podinfo", "gPRC service name")
        fs.String("level", "info", "log level debug, info, warn, error, fatal or panic")
        fs.StringSlice("backend-url", []string{}, "backend service URL")
        fs.Duration("http-client-timeout", 2*time.Minute, "client timeout duration")
        fs.Duration("http-server-timeout", 30*time.Second, "server read and write timeout duration")
        fs.Duration("server-shutdown-timeout", 5*time.Second, "server graceful shutdown timeout duration")
        fs.String("data-path", "/data", "data local path")
        fs.String("config-path", "", "config dir path")
        fs.String("cert-path", "/data/cert", "certificate path for HTTPS port")
        fs.String("config", "config.yaml", "config file name")
        fs.String("ui-path", "./ui", "UI local path")
        fs.String("ui-logo", "", "UI logo")
        fs.String("ui-color", "#34577c", "UI color")
        fs.String("ui-message", fmt.Sprintf("greetings from podinfo v%v", version.VERSION), "UI message")
        fs.Bool("h2c", false, "allow upgrading to H2C")
        fs.Bool("random-delay", false, "between 0 and 5 seconds random delay by default")
        fs.String("random-delay-unit", "s", "either s(seconds) or ms(milliseconds")
        fs.Int("random-delay-min", 0, "min for random delay: 0 by default")
        fs.Int("random-delay-max", 5, "max for random delay: 5 by default")
        fs.Bool("random-error", false, "1/3 chances of a random response error")
        fs.Bool("unhealthy", false, "when set, healthy state is never reached")
        fs.Bool("unready", false, "when set, ready state is never reached")
        fs.Int("stress-cpu", 0, "number of CPU cores with 100 load")
        fs.Int("stress-memory", 0, "MB of data to load into memory")
        fs.String("cache-server", "", "Redis address in the format 'tcp://&lt;host&gt;:&lt;port&gt;'")
        fs.String("otel-service-name", "", "service name for reporting to open telemetry address, when not set tracing is disabled")

        versionFlag := fs.BoolP("version", "v", false, "get version number")

        // parse flags
        err := fs.Parse(os.Args[1:])
        switch </span>{
        case err == pflag.ErrHelp:<span class="cov0" title="0">
                os.Exit(0)</span>
        case err != nil:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Error: %s\n\n", err.Error())
                fs.PrintDefaults()
                os.Exit(2)</span>
        case *versionFlag:<span class="cov0" title="0">
                fmt.Println(version.VERSION)
                os.Exit(0)</span>
        }

        // bind flags and environment variables
        <span class="cov0" title="0">viper.BindPFlags(fs)
        viper.RegisterAlias("backendUrl", "backend-url")
        hostname, _ := os.Hostname()
        viper.SetDefault("jwt-secret", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9")
        viper.SetDefault("ui-logo", "https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif")
        viper.Set("hostname", hostname)
        viper.Set("version", version.VERSION)
        viper.Set("revision", version.REVISION)
        viper.SetEnvPrefix("PODINFO")
        viper.SetEnvKeyReplacer(strings.NewReplacer("-", "_"))
        viper.AutomaticEnv()

        // load config from file
        if _, fileErr := os.Stat(filepath.Join(viper.GetString("config-path"), viper.GetString("config"))); fileErr == nil </span><span class="cov0" title="0">{
                viper.SetConfigName(strings.Split(viper.GetString("config"), ".")[0])
                viper.AddConfigPath(viper.GetString("config-path"))
                if readErr := viper.ReadInConfig(); readErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error reading config file, %v\n", readErr)
                }</span>
        }

        // configure logging
        <span class="cov0" title="0">logger, _ := initZap(viper.GetString("level"))
        defer logger.Sync()
        stdLog := zap.RedirectStdLog(logger)
        defer stdLog()

        // start stress tests if any
        beginStressTest(viper.GetInt("stress-cpu"), viper.GetInt("stress-memory"), logger)

        // validate port
        if _, err := strconv.Atoi(viper.GetString("port")); err != nil </span><span class="cov0" title="0">{
                port, _ := fs.GetInt("port")
                viper.Set("port", strconv.Itoa(port))
        }</span>

        // validate secure port
        <span class="cov0" title="0">if _, err := strconv.Atoi(viper.GetString("secure-port")); err != nil </span><span class="cov0" title="0">{
                securePort, _ := fs.GetInt("secure-port")
                viper.Set("secure-port", strconv.Itoa(securePort))
        }</span>

        // validate random delay options
        <span class="cov0" title="0">if viper.GetInt("random-delay-max") &lt; viper.GetInt("random-delay-min") </span><span class="cov0" title="0">{
                logger.Panic("`--random-delay-max` should be greater than `--random-delay-min`")
        }</span>

        <span class="cov0" title="0">switch delayUnit := viper.GetString("random-delay-unit"); delayUnit </span>{
        case
                "s",
                "ms":<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                logger.Panic("`random-delay-unit` accepted values are: s|ms")</span>
        }

        // load gRPC server config
        <span class="cov0" title="0">var grpcCfg grpc.Config
        if err := viper.Unmarshal(&amp;grpcCfg); err != nil </span><span class="cov0" title="0">{
                logger.Panic("config unmarshal failed", zap.Error(err))
        }</span>

        // start gRPC server
        <span class="cov0" title="0">var grpcServer *go_grpc.Server
        if grpcCfg.Port &gt; 0 </span><span class="cov0" title="0">{
                grpcSrv, _ := grpc.NewServer(&amp;grpcCfg, logger)
                //grpcinfoSrv, _ := grpc.NewInfoServer(&amp;grpcCfg)

                grpcServer = grpcSrv.ListenAndServe()
        }</span>

        // load HTTP server config
        <span class="cov0" title="0">var srvCfg http.Config
        if err := viper.Unmarshal(&amp;srvCfg); err != nil </span><span class="cov0" title="0">{
                logger.Panic("config unmarshal failed", zap.Error(err))
        }</span>

        // log version and port
        <span class="cov0" title="0">logger.Info("Starting podinfo",
                zap.String("version", viper.GetString("version")),
                zap.String("revision", viper.GetString("revision")),
                zap.String("port", srvCfg.Port),
        )

        // start HTTP server
        srv, _ := http.NewServer(&amp;srvCfg, logger)
        httpServer, httpsServer, healthy, ready := srv.ListenAndServe()

        // graceful shutdown
        stopCh := signals.SetupSignalHandler()
        sd, _ := signals.NewShutdown(srvCfg.ServerShutdownTimeout, logger)
        sd.Graceful(stopCh, httpServer, httpsServer, grpcServer, healthy, ready)</span>
}

func initZap(logLevel string) (*zap.Logger, error) <span class="cov0" title="0">{
        level := zap.NewAtomicLevelAt(zapcore.InfoLevel)
        switch logLevel </span>{
        case "debug":<span class="cov0" title="0">
                level = zap.NewAtomicLevelAt(zapcore.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                level = zap.NewAtomicLevelAt(zapcore.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                level = zap.NewAtomicLevelAt(zapcore.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                level = zap.NewAtomicLevelAt(zapcore.ErrorLevel)</span>
        case "fatal":<span class="cov0" title="0">
                level = zap.NewAtomicLevelAt(zapcore.FatalLevel)</span>
        case "panic":<span class="cov0" title="0">
                level = zap.NewAtomicLevelAt(zapcore.PanicLevel)</span>
        }

        <span class="cov0" title="0">zapEncoderConfig := zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.LowercaseLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        zapConfig := zap.Config{
                Level:       level,
                Development: false,
                Sampling: &amp;zap.SamplingConfig{
                        Initial:    100,
                        Thereafter: 100,
                },
                Encoding:         "json",
                EncoderConfig:    zapEncoderConfig,
                OutputPaths:      []string{"stderr"},
                ErrorOutputPaths: []string{"stderr"},
        }

        return zapConfig.Build()</span>
}

var stressMemoryPayload []byte

func beginStressTest(cpus int, mem int, logger *zap.Logger) <span class="cov0" title="0">{
        done := make(chan int)
        if cpus &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("starting CPU stress", zap.Int("cores", cpus))
                for i := 0; i &lt; cpus; i++ </span><span class="cov0" title="0">{
                        go func() </span><span class="cov0" title="0">{
                                for </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-done:<span class="cov0" title="0">
                                                return</span>
                                        default:<span class="cov0" title="0"></span>

                                        }
                                }
                        }()
                }
        }

        <span class="cov0" title="0">if mem &gt; 0 </span><span class="cov0" title="0">{
                path := "/tmp/podinfo.data"
                f, err := os.Create(path)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("memory stress failed", zap.Error(err))
                }</span>

                <span class="cov0" title="0">if err := f.Truncate(1000000 * int64(mem)); err != nil </span><span class="cov0" title="0">{
                        logger.Error("memory stress failed", zap.Error(err))
                }</span>

                <span class="cov0" title="0">stressMemoryPayload, err = os.ReadFile(path)
                f.Close()
                os.Remove(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("memory stress failed", zap.Error(err))
                }</span>
                <span class="cov0" title="0">logger.Info("starting MEMORY stress", zap.Int("memory", len(stressMemoryPayload)))</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package grpc

import (
        "context"
        "time"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/delay"
        "go.uber.org/zap"
)

type DelayServer struct {
        pb.UnimplementedDelayServiceServer
        config *Config
        logger *zap.Logger
}

func (s *DelayServer) Delay(ctx context.Context, delayInput *pb.DelayRequest) (*pb.DelayResponse, error) <span class="cov8" title="1">{

        time.Sleep(time.Duration(delayInput.Seconds) * time.Second)
        return &amp;pb.DelayResponse{Message: delayInput.Seconds}, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.0
// source: delay/delay.proto

package delay

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type DelayRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
}

func (x *DelayRequest) Reset() <span class="cov0" title="0">{
        *x = DelayRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_delay_delay_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DelayRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DelayRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DelayRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_delay_delay_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DelayRequest.ProtoReflect.Descriptor instead.
func (*DelayRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_delay_delay_proto_rawDescGZIP(), []int{0}
}</span>

func (x *DelayRequest) GetSeconds() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Seconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DelayResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Message int64 `protobuf:"varint,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *DelayResponse) Reset() <span class="cov0" title="0">{
        *x = DelayResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_delay_delay_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DelayResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DelayResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DelayResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_delay_delay_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DelayResponse.ProtoReflect.Descriptor instead.
func (*DelayResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_delay_delay_proto_rawDescGZIP(), []int{1}
}</span>

func (x *DelayResponse) GetMessage() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_delay_delay_proto protoreflect.FileDescriptor

var file_delay_delay_proto_rawDesc = []byte{
        0x0a, 0x11, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x2f, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x12, 0x05, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x22, 0x28, 0x0a, 0x0c, 0x44, 0x65,
        0x6c, 0x61, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65,
        0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x73, 0x65, 0x63,
        0x6f, 0x6e, 0x64, 0x73, 0x22, 0x29, 0x0a, 0x0d, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x32,
        0x44, 0x0a, 0x0c, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
        0x34, 0x0a, 0x05, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x12, 0x13, 0x2e, 0x64, 0x65, 0x6c, 0x61, 0x79,
        0x2e, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e,
        0x64, 0x65, 0x6c, 0x61, 0x79, 0x2e, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x09, 0x5a, 0x07, 0x2e, 0x2f, 0x64, 0x65, 0x6c, 0x61, 0x79,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_delay_delay_proto_rawDescOnce sync.Once
        file_delay_delay_proto_rawDescData = file_delay_delay_proto_rawDesc
)

func file_delay_delay_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_delay_delay_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_delay_delay_proto_rawDescData = protoimpl.X.CompressGZIP(file_delay_delay_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_delay_delay_proto_rawDescData</span>
}

var file_delay_delay_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_delay_delay_proto_goTypes = []interface{}{
        (*DelayRequest)(nil),  // 0: delay.DelayRequest
        (*DelayResponse)(nil), // 1: delay.DelayResponse
}
var file_delay_delay_proto_depIdxs = []int32{
        0, // 0: delay.DelayService.Delay:input_type -&gt; delay.DelayRequest
        1, // 1: delay.DelayService.Delay:output_type -&gt; delay.DelayResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_delay_delay_proto_init() }</span>
func file_delay_delay_proto_init() <span class="cov0" title="0">{
        if File_delay_delay_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_delay_delay_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DelayRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_delay_delay_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DelayResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_delay_delay_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_delay_delay_proto_goTypes,
                DependencyIndexes: file_delay_delay_proto_depIdxs,
                MessageInfos:      file_delay_delay_proto_msgTypes,
        }.Build()
        File_delay_delay_proto = out.File
        file_delay_delay_proto_rawDesc = nil
        file_delay_delay_proto_goTypes = nil
        file_delay_delay_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0
// source: delay/delay.proto

package delay

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DelayServiceClient is the client API for DelayService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DelayServiceClient interface {
        Delay(ctx context.Context, in *DelayRequest, opts ...grpc.CallOption) (*DelayResponse, error)
}

type delayServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewDelayServiceClient(cc grpc.ClientConnInterface) DelayServiceClient <span class="cov0" title="0">{
        return &amp;delayServiceClient{cc}
}</span>

func (c *delayServiceClient) Delay(ctx context.Context, in *DelayRequest, opts ...grpc.CallOption) (*DelayResponse, error) <span class="cov0" title="0">{
        out := new(DelayResponse)
        err := c.cc.Invoke(ctx, "/delay.DelayService/Delay", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// DelayServiceServer is the server API for DelayService service.
// All implementations must embed UnimplementedDelayServiceServer
// for forward compatibility
type DelayServiceServer interface {
        Delay(context.Context, *DelayRequest) (*DelayResponse, error)
        mustEmbedUnimplementedDelayServiceServer()
}

// UnimplementedDelayServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDelayServiceServer struct {
}

func (UnimplementedDelayServiceServer) Delay(context.Context, *DelayRequest) (*DelayResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Delay not implemented")
}</span>
func (UnimplementedDelayServiceServer) mustEmbedUnimplementedDelayServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeDelayServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DelayServiceServer will
// result in compilation errors.
type UnsafeDelayServiceServer interface {
        mustEmbedUnimplementedDelayServiceServer()
}

func RegisterDelayServiceServer(s grpc.ServiceRegistrar, srv DelayServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;DelayService_ServiceDesc, srv)
}</span>

func _DelayService_Delay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DelayRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DelayServiceServer).Delay(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/delay.DelayService/Delay",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DelayServiceServer).Delay(ctx, req.(*DelayRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// DelayService_ServiceDesc is the grpc.ServiceDesc for DelayService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DelayService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "delay.DelayService",
        HandlerType: (*DelayServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Delay",
                        Handler:    _DelayService_Delay_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "delay/delay.proto",
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package grpc

import (
        "context"

        "github.com/stefanprodan/podinfo/pkg/api/grpc/echo"
        "go.uber.org/zap"
)

type echoServer struct {
        echo.UnimplementedEchoServiceServer
        config *Config
        logger *zap.Logger
}

func (s *echoServer) Echo(ctx context.Context, message *echo.Message) (*echo.Message, error) <span class="cov8" title="1">{

        s.logger.Info("Received message body from client:", zap.String("input body", message.Body))
        return &amp;echo.Message{Body: message.Body}, nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.26.0
//         protoc        v4.24.3
// source: echo/echo.proto

package echo

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Message struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Body string `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
}

func (x *Message) Reset() <span class="cov0" title="0">{
        *x = Message{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_echo_echo_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Message) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Message) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Message) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_echo_echo_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_echo_echo_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Message) GetBody() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Body
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_echo_echo_proto protoreflect.FileDescriptor

var file_echo_echo_proto_rawDesc = []byte{
        0x0a, 0x0f, 0x65, 0x63, 0x68, 0x6f, 0x2f, 0x65, 0x63, 0x68, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x04, 0x65, 0x63, 0x68, 0x6f, 0x22, 0x1d, 0x0a, 0x07, 0x4d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x32, 0x35, 0x0a, 0x0b, 0x45, 0x63, 0x68, 0x6f, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x26, 0x0a, 0x04, 0x45, 0x63, 0x68, 0x6f, 0x12, 0x0d, 0x2e,
        0x65, 0x63, 0x68, 0x6f, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x0d, 0x2e, 0x65,
        0x63, 0x68, 0x6f, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x42, 0x08, 0x5a,
        0x06, 0x2e, 0x2f, 0x65, 0x63, 0x68, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_echo_echo_proto_rawDescOnce sync.Once
        file_echo_echo_proto_rawDescData = file_echo_echo_proto_rawDesc
)

func file_echo_echo_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_echo_echo_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_echo_echo_proto_rawDescData = protoimpl.X.CompressGZIP(file_echo_echo_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_echo_echo_proto_rawDescData</span>
}

var file_echo_echo_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_echo_echo_proto_goTypes = []interface{}{
        (*Message)(nil), // 0: echo.Message
}
var file_echo_echo_proto_depIdxs = []int32{
        0, // 0: echo.EchoService.Echo:input_type -&gt; echo.Message
        0, // 1: echo.EchoService.Echo:output_type -&gt; echo.Message
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_echo_echo_proto_init() }</span>
func file_echo_echo_proto_init() <span class="cov0" title="0">{
        if File_echo_echo_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_echo_echo_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Message); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_echo_echo_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_echo_echo_proto_goTypes,
                DependencyIndexes: file_echo_echo_proto_depIdxs,
                MessageInfos:      file_echo_echo_proto_msgTypes,
        }.Build()
        File_echo_echo_proto = out.File
        file_echo_echo_proto_rawDesc = nil
        file_echo_echo_proto_goTypes = nil
        file_echo_echo_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: echo/echo.proto

package echo

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        EchoService_Echo_FullMethodName = "/echo.EchoService/Echo"
)

// EchoServiceClient is the client API for EchoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EchoServiceClient interface {
        Echo(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
}

type echoServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewEchoServiceClient(cc grpc.ClientConnInterface) EchoServiceClient <span class="cov0" title="0">{
        return &amp;echoServiceClient{cc}
}</span>

func (c *echoServiceClient) Echo(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) <span class="cov0" title="0">{
        out := new(Message)
        err := c.cc.Invoke(ctx, EchoService_Echo_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// EchoServiceServer is the server API for EchoService service.
// All implementations must embed UnimplementedEchoServiceServer
// for forward compatibility
type EchoServiceServer interface {
        Echo(context.Context, *Message) (*Message, error)
        mustEmbedUnimplementedEchoServiceServer()
}

// UnimplementedEchoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEchoServiceServer struct {
}

func (UnimplementedEchoServiceServer) Echo(context.Context, *Message) (*Message, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}</span>
func (UnimplementedEchoServiceServer) mustEmbedUnimplementedEchoServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeEchoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EchoServiceServer will
// result in compilation errors.
type UnsafeEchoServiceServer interface {
        mustEmbedUnimplementedEchoServiceServer()
}

func RegisterEchoServiceServer(s grpc.ServiceRegistrar, srv EchoServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;EchoService_ServiceDesc, srv)
}</span>

func _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Message)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EchoServiceServer).Echo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EchoService_Echo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EchoServiceServer).Echo(ctx, req.(*Message))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// EchoService_ServiceDesc is the grpc.ServiceDesc for EchoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EchoService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "echo.EchoService",
        HandlerType: (*EchoServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Echo",
                        Handler:    _EchoService_Echo_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "echo/echo.proto",
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package grpc

import (
        "context"
        "go.uber.org/zap"
        "os"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/env"
)

type EnvServer struct {
        pb.UnimplementedEnvServiceServer
        config *Config
        logger *zap.Logger
}

func (s *EnvServer) Env(ctx context.Context, envInput *pb.EnvRequest) (*pb.EnvResponse, error) <span class="cov8" title="1">{
        return &amp;pb.EnvResponse{EnvVars: os.Environ()}, nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.0
// source: env/env.proto

package env

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EnvRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *EnvRequest) Reset() <span class="cov0" title="0">{
        *x = EnvRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_env_env_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EnvRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EnvRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EnvRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_env_env_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EnvRequest.ProtoReflect.Descriptor instead.
func (*EnvRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_env_env_proto_rawDescGZIP(), []int{0}
}</span>

type EnvResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        EnvVars []string `protobuf:"bytes,1,rep,name=envVars,proto3" json:"envVars,omitempty"`
}

func (x *EnvResponse) Reset() <span class="cov0" title="0">{
        *x = EnvResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_env_env_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EnvResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EnvResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EnvResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_env_env_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EnvResponse.ProtoReflect.Descriptor instead.
func (*EnvResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_env_env_proto_rawDescGZIP(), []int{1}
}</span>

func (x *EnvResponse) GetEnvVars() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnvVars
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_env_env_proto protoreflect.FileDescriptor

var file_env_env_proto_rawDesc = []byte{
        0x0a, 0x0d, 0x65, 0x6e, 0x76, 0x2f, 0x65, 0x6e, 0x76, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x03, 0x65, 0x6e, 0x76, 0x22, 0x0c, 0x0a, 0x0a, 0x45, 0x6e, 0x76, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x22, 0x27, 0x0a, 0x0b, 0x45, 0x6e, 0x76, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x76, 0x56, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x07, 0x65, 0x6e, 0x76, 0x56, 0x61, 0x72, 0x73, 0x32, 0x38, 0x0a, 0x0a, 0x45,
        0x6e, 0x76, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x2a, 0x0a, 0x03, 0x45, 0x6e, 0x76,
        0x12, 0x0f, 0x2e, 0x65, 0x6e, 0x76, 0x2e, 0x45, 0x6e, 0x76, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x10, 0x2e, 0x65, 0x6e, 0x76, 0x2e, 0x45, 0x6e, 0x76, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x2f, 0x65, 0x6e, 0x76, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_env_env_proto_rawDescOnce sync.Once
        file_env_env_proto_rawDescData = file_env_env_proto_rawDesc
)

func file_env_env_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_env_env_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_env_env_proto_rawDescData = protoimpl.X.CompressGZIP(file_env_env_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_env_env_proto_rawDescData</span>
}

var file_env_env_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_env_env_proto_goTypes = []interface{}{
        (*EnvRequest)(nil),  // 0: env.EnvRequest
        (*EnvResponse)(nil), // 1: env.EnvResponse
}
var file_env_env_proto_depIdxs = []int32{
        0, // 0: env.EnvService.Env:input_type -&gt; env.EnvRequest
        1, // 1: env.EnvService.Env:output_type -&gt; env.EnvResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_env_env_proto_init() }</span>
func file_env_env_proto_init() <span class="cov0" title="0">{
        if File_env_env_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_env_env_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EnvRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_env_env_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EnvResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_env_env_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_env_env_proto_goTypes,
                DependencyIndexes: file_env_env_proto_depIdxs,
                MessageInfos:      file_env_env_proto_msgTypes,
        }.Build()
        File_env_env_proto = out.File
        file_env_env_proto_rawDesc = nil
        file_env_env_proto_goTypes = nil
        file_env_env_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0
// source: env/env.proto

package env

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EnvServiceClient is the client API for EnvService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnvServiceClient interface {
        Env(ctx context.Context, in *EnvRequest, opts ...grpc.CallOption) (*EnvResponse, error)
}

type envServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewEnvServiceClient(cc grpc.ClientConnInterface) EnvServiceClient <span class="cov0" title="0">{
        return &amp;envServiceClient{cc}
}</span>

func (c *envServiceClient) Env(ctx context.Context, in *EnvRequest, opts ...grpc.CallOption) (*EnvResponse, error) <span class="cov0" title="0">{
        out := new(EnvResponse)
        err := c.cc.Invoke(ctx, "/env.EnvService/Env", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// EnvServiceServer is the server API for EnvService service.
// All implementations must embed UnimplementedEnvServiceServer
// for forward compatibility
type EnvServiceServer interface {
        Env(context.Context, *EnvRequest) (*EnvResponse, error)
        mustEmbedUnimplementedEnvServiceServer()
}

// UnimplementedEnvServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEnvServiceServer struct {
}

func (UnimplementedEnvServiceServer) Env(context.Context, *EnvRequest) (*EnvResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Env not implemented")
}</span>
func (UnimplementedEnvServiceServer) mustEmbedUnimplementedEnvServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeEnvServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnvServiceServer will
// result in compilation errors.
type UnsafeEnvServiceServer interface {
        mustEmbedUnimplementedEnvServiceServer()
}

func RegisterEnvServiceServer(s grpc.ServiceRegistrar, srv EnvServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;EnvService_ServiceDesc, srv)
}</span>

func _EnvService_Env_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(EnvRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EnvServiceServer).Env(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/env.EnvService/Env",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EnvServiceServer).Env(ctx, req.(*EnvRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// EnvService_ServiceDesc is the grpc.ServiceDesc for EnvService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnvService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "env.EnvService",
        HandlerType: (*EnvServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Env",
                        Handler:    _EnvService_Env_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "env/env.proto",
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package grpc

import (
        "context"
        "strings"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/headers"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

type HeaderServer struct {
        pb.UnimplementedHeaderServiceServer
        config *Config
        logger *zap.Logger
}

func (s *HeaderServer) Header(ctx context.Context, in *pb.HeaderRequest) (*pb.HeaderResponse, error) <span class="cov8" title="1">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.DataLoss, "UnaryEcho: failed to get metadata")
        }</span>

        // Creating slices beacause echoing the header metadata can't be predetermined by the proto contract
        <span class="cov8" title="1">res := []string{}
        for i, e := range md </span><span class="cov8" title="1">{
                res = append(res, i+"="+strings.Join(e, ","))
        }</span>

        <span class="cov8" title="1">return &amp;pb.HeaderResponse{Headers: res}, nil</span>

}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.0
// source: headers/headers.proto

package header

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HeaderRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *HeaderRequest) Reset() <span class="cov0" title="0">{
        *x = HeaderRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_headers_headers_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HeaderRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HeaderRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HeaderRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_headers_headers_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HeaderRequest.ProtoReflect.Descriptor instead.
func (*HeaderRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_headers_headers_proto_rawDescGZIP(), []int{0}
}</span>

type HeaderResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Headers []string `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (x *HeaderResponse) Reset() <span class="cov0" title="0">{
        *x = HeaderResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_headers_headers_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HeaderResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HeaderResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HeaderResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_headers_headers_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HeaderResponse.ProtoReflect.Descriptor instead.
func (*HeaderResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_headers_headers_proto_rawDescGZIP(), []int{1}
}</span>

func (x *HeaderResponse) GetHeaders() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_headers_headers_proto protoreflect.FileDescriptor

var file_headers_headers_proto_rawDesc = []byte{
        0x0a, 0x15, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
        0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x22,
        0x0f, 0x0a, 0x0d, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x22, 0x2a, 0x0a, 0x0e, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x32, 0x4a, 0x0a, 0x0d,
        0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x39, 0x0a,
        0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
        0x2e, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
        0x2e, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x2f, 0x68, 0x65,
        0x61, 0x64, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_headers_headers_proto_rawDescOnce sync.Once
        file_headers_headers_proto_rawDescData = file_headers_headers_proto_rawDesc
)

func file_headers_headers_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_headers_headers_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_headers_headers_proto_rawDescData = protoimpl.X.CompressGZIP(file_headers_headers_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_headers_headers_proto_rawDescData</span>
}

var file_headers_headers_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_headers_headers_proto_goTypes = []interface{}{
        (*HeaderRequest)(nil),  // 0: header.headerRequest
        (*HeaderResponse)(nil), // 1: header.headerResponse
}
var file_headers_headers_proto_depIdxs = []int32{
        0, // 0: header.HeaderService.Header:input_type -&gt; header.headerRequest
        1, // 1: header.HeaderService.Header:output_type -&gt; header.headerResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_headers_headers_proto_init() }</span>
func file_headers_headers_proto_init() <span class="cov0" title="0">{
        if File_headers_headers_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_headers_headers_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HeaderRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_headers_headers_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HeaderResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_headers_headers_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_headers_headers_proto_goTypes,
                DependencyIndexes: file_headers_headers_proto_depIdxs,
                MessageInfos:      file_headers_headers_proto_msgTypes,
        }.Build()
        File_headers_headers_proto = out.File
        file_headers_headers_proto_rawDesc = nil
        file_headers_headers_proto_goTypes = nil
        file_headers_headers_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0
// source: headers/headers.proto

package header

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HeaderServiceClient is the client API for HeaderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HeaderServiceClient interface {
        Header(ctx context.Context, in *HeaderRequest, opts ...grpc.CallOption) (*HeaderResponse, error)
}

type headerServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewHeaderServiceClient(cc grpc.ClientConnInterface) HeaderServiceClient <span class="cov0" title="0">{
        return &amp;headerServiceClient{cc}
}</span>

func (c *headerServiceClient) Header(ctx context.Context, in *HeaderRequest, opts ...grpc.CallOption) (*HeaderResponse, error) <span class="cov0" title="0">{
        out := new(HeaderResponse)
        err := c.cc.Invoke(ctx, "/header.HeaderService/Header", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// HeaderServiceServer is the server API for HeaderService service.
// All implementations must embed UnimplementedHeaderServiceServer
// for forward compatibility
type HeaderServiceServer interface {
        Header(context.Context, *HeaderRequest) (*HeaderResponse, error)
        mustEmbedUnimplementedHeaderServiceServer()
}

// UnimplementedHeaderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHeaderServiceServer struct {
}

func (UnimplementedHeaderServiceServer) Header(context.Context, *HeaderRequest) (*HeaderResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Header not implemented")
}</span>
func (UnimplementedHeaderServiceServer) mustEmbedUnimplementedHeaderServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeHeaderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HeaderServiceServer will
// result in compilation errors.
type UnsafeHeaderServiceServer interface {
        mustEmbedUnimplementedHeaderServiceServer()
}

func RegisterHeaderServiceServer(s grpc.ServiceRegistrar, srv HeaderServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;HeaderService_ServiceDesc, srv)
}</span>

func _HeaderService_Header_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(HeaderRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(HeaderServiceServer).Header(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/header.HeaderService/Header",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(HeaderServiceServer).Header(ctx, req.(*HeaderRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// HeaderService_ServiceDesc is the grpc.ServiceDesc for HeaderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HeaderService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "header.HeaderService",
        HandlerType: (*HeaderServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Header",
                        Handler:    _HeaderService_Header_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "headers/headers.proto",
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package grpc

import (
        "context"
        "go.uber.org/zap"
        "log"
        "runtime"
        "strconv"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/info"
        "github.com/stefanprodan/podinfo/pkg/version"
)

type infoServer struct {
        pb.UnimplementedInfoServiceServer
        config *Config
        logger *zap.Logger
}

func (s *infoServer) Info(ctx context.Context, message *pb.InfoRequest) (*pb.InfoResponse, error) <span class="cov8" title="1">{

        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Println("Recovered from panic:", r)
                }</span>
        }()

        <span class="cov8" title="1">data := RuntimeResponse{
                Hostname:     s.config.Hostname,
                Version:      version.VERSION,
                Revision:     version.REVISION,
                Color:        s.config.UIColor,
                Logo:         s.config.UILogo,
                Message:      s.config.UIMessage,
                Goos:         runtime.GOOS,
                Goarch:       runtime.GOARCH,
                Runtime:      runtime.Version(),
                Numgoroutine: strconv.FormatInt(int64(runtime.NumGoroutine()), 10),
                Numcpu:       strconv.FormatInt(int64(runtime.NumCPU()), 10),
        }

        return &amp;pb.InfoResponse{
                Hostname:     data.Hostname,
                Version:      data.Version,
                Revision:     data.Revision,
                Color:        data.Color,
                Logo:         data.Logo,
                Message:      data.Message,
                Goos:         data.Goos,
                Goarch:       data.Goarch,
                Runtime:      data.Runtime,
                Numgoroutine: data.Numgoroutine,
                Numcpu:       data.Numcpu,
        }, nil</span>

}

type RuntimeResponse struct {
        Hostname     string `json:"hostname"`
        Version      string `json:"version"`
        Revision     string `json:"revision"`
        Color        string `json:"color"`
        Logo         string `json:"logo"`
        Message      string `json:"message"`
        Goos         string `json:"goos"`
        Goarch       string `json:"goarch"`
        Runtime      string `json:"runtime"`
        Numgoroutine string `json:"num_goroutine"`
        Numcpu       string `json:"num_cpu"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.0
// source: info/info.proto

package info

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type InfoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *InfoRequest) Reset() <span class="cov0" title="0">{
        *x = InfoRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_info_info_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *InfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*InfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *InfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_info_info_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use InfoRequest.ProtoReflect.Descriptor instead.
func (*InfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_info_info_proto_rawDescGZIP(), []int{0}
}</span>

type InfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Hostname     string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
        Version      string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
        Revision     string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
        Color        string `protobuf:"bytes,4,opt,name=color,proto3" json:"color,omitempty"`
        Logo         string `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty"`
        Message      string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
        Goos         string `protobuf:"bytes,7,opt,name=goos,proto3" json:"goos,omitempty"`
        Goarch       string `protobuf:"bytes,8,opt,name=goarch,proto3" json:"goarch,omitempty"`
        Runtime      string `protobuf:"bytes,9,opt,name=runtime,proto3" json:"runtime,omitempty"`
        Numgoroutine string `protobuf:"bytes,10,opt,name=numgoroutine,proto3" json:"numgoroutine,omitempty"`
        Numcpu       string `protobuf:"bytes,11,opt,name=numcpu,proto3" json:"numcpu,omitempty"`
}

func (x *InfoResponse) Reset() <span class="cov0" title="0">{
        *x = InfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_info_info_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *InfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*InfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *InfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_info_info_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use InfoResponse.ProtoReflect.Descriptor instead.
func (*InfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_info_info_proto_rawDescGZIP(), []int{1}
}</span>

func (x *InfoResponse) GetHostname() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Hostname
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetRevision() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Revision
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetColor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Color
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetLogo() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Logo
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetGoos() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Goos
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetGoarch() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Goarch
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetRuntime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Runtime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetNumgoroutine() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Numgoroutine
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InfoResponse) GetNumcpu() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Numcpu
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_info_info_proto protoreflect.FileDescriptor

var file_info_info_proto_rawDesc = []byte{
        0x0a, 0x0f, 0x69, 0x6e, 0x66, 0x6f, 0x2f, 0x69, 0x6e, 0x66, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0x0d, 0x0a, 0x0b, 0x49, 0x6e, 0x66, 0x6f, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xa6, 0x02, 0x0a, 0x0c, 0x49, 0x6e, 0x66, 0x6f, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e,
        0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a,
        0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6c,
        0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x12,
        0x12, 0x0a, 0x04, 0x6c, 0x6f, 0x67, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6c,
        0x6f, 0x67, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x12, 0x0a,
        0x04, 0x67, 0x6f, 0x6f, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x67, 0x6f, 0x6f,
        0x73, 0x12, 0x16, 0x0a, 0x06, 0x67, 0x6f, 0x61, 0x72, 0x63, 0x68, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x67, 0x6f, 0x61, 0x72, 0x63, 0x68, 0x12, 0x18, 0x0a, 0x07, 0x72, 0x75, 0x6e,
        0x74, 0x69, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x75, 0x6e, 0x74,
        0x69, 0x6d, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x67, 0x6f, 0x72, 0x6f, 0x75, 0x74,
        0x69, 0x6e, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6e, 0x75, 0x6d, 0x67, 0x6f,
        0x72, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x63, 0x70,
        0x75, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x75, 0x6d, 0x63, 0x70, 0x75, 0x32,
        0x3e, 0x0a, 0x0b, 0x49, 0x6e, 0x66, 0x6f, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x2f,
        0x0a, 0x04, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x11, 0x2e, 0x69, 0x6e, 0x66, 0x6f, 0x2e, 0x49, 0x6e,
        0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x12, 0x2e, 0x69, 0x6e, 0x66, 0x6f,
        0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42,
        0x08, 0x5a, 0x06, 0x2e, 0x2f, 0x69, 0x6e, 0x66, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var (
        file_info_info_proto_rawDescOnce sync.Once
        file_info_info_proto_rawDescData = file_info_info_proto_rawDesc
)

func file_info_info_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_info_info_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_info_info_proto_rawDescData = protoimpl.X.CompressGZIP(file_info_info_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_info_info_proto_rawDescData</span>
}

var file_info_info_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_info_info_proto_goTypes = []interface{}{
        (*InfoRequest)(nil),  // 0: info.InfoRequest
        (*InfoResponse)(nil), // 1: info.InfoResponse
}
var file_info_info_proto_depIdxs = []int32{
        0, // 0: info.InfoService.Info:input_type -&gt; info.InfoRequest
        1, // 1: info.InfoService.Info:output_type -&gt; info.InfoResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_info_info_proto_init() }</span>
func file_info_info_proto_init() <span class="cov0" title="0">{
        if File_info_info_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_info_info_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*InfoRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_info_info_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*InfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_info_info_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_info_info_proto_goTypes,
                DependencyIndexes: file_info_info_proto_depIdxs,
                MessageInfos:      file_info_info_proto_msgTypes,
        }.Build()
        File_info_info_proto = out.File
        file_info_info_proto_rawDesc = nil
        file_info_info_proto_goTypes = nil
        file_info_info_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0
// source: info/info.proto

package info

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InfoServiceClient is the client API for InfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfoServiceClient interface {
        Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
}

type infoServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewInfoServiceClient(cc grpc.ClientConnInterface) InfoServiceClient <span class="cov0" title="0">{
        return &amp;infoServiceClient{cc}
}</span>

func (c *infoServiceClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) <span class="cov0" title="0">{
        out := new(InfoResponse)
        err := c.cc.Invoke(ctx, "/info.InfoService/Info", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// InfoServiceServer is the server API for InfoService service.
// All implementations must embed UnimplementedInfoServiceServer
// for forward compatibility
type InfoServiceServer interface {
        Info(context.Context, *InfoRequest) (*InfoResponse, error)
        mustEmbedUnimplementedInfoServiceServer()
}

// UnimplementedInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInfoServiceServer struct {
}

func (UnimplementedInfoServiceServer) Info(context.Context, *InfoRequest) (*InfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}</span>
func (UnimplementedInfoServiceServer) mustEmbedUnimplementedInfoServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfoServiceServer will
// result in compilation errors.
type UnsafeInfoServiceServer interface {
        mustEmbedUnimplementedInfoServiceServer()
}

func RegisterInfoServiceServer(s grpc.ServiceRegistrar, srv InfoServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;InfoService_ServiceDesc, srv)
}</span>

func _InfoService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(InfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(InfoServiceServer).Info(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/info.InfoService/Info",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(InfoServiceServer).Info(ctx, req.(*InfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// InfoService_ServiceDesc is the grpc.ServiceDesc for InfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InfoService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "info.InfoService",
        HandlerType: (*InfoServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Info",
                        Handler:    _InfoService_Info_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "info/info.proto",
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package grpc

import (
        "go.uber.org/zap"
)

func NewMockGrpcServer() *Server <span class="cov8" title="1">{
        config := &amp;Config{
                Port: 9999,
                // ServerShutdownTimeout: 5 * time.Second,
                // HttpServerTimeout:     30 * time.Second,
                BackendURL: []string{},
                ConfigPath: "/config",
                DataPath:   "/data",
                // HttpClientTimeout:     30 * time.Second,
                UIColor:   "blue",
                UIPath:    ".ui",
                UIMessage: "Greetings",
                Hostname:  "localhost",
        }

        logger, _ := zap.NewDevelopment()

        return &amp;Server{
                //router: mux.NewRouter(),
                logger: logger,
                config: config,
                //tracer: trace.NewNoopTracerProvider().Tracer("mock"),
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package grpc

import (
        "context"
        // "log"
        "os"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/panic"
        "go.uber.org/zap"
)

type PanicServer struct {
        pb.UnimplementedPanicServiceServer
        config *Config
        logger *zap.Logger
}

func (s *PanicServer) Panic(ctx context.Context, req *pb.PanicRequest) (*pb.PanicResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Panic command received")
        os.Exit(225)
        return &amp;pb.PanicResponse{}, nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v3.6.1
// source: panic.proto

package panic

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PanicRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *PanicRequest) Reset() <span class="cov0" title="0">{
        *x = PanicRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_panic_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PanicRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PanicRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PanicRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_panic_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PanicRequest.ProtoReflect.Descriptor instead.
func (*PanicRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_panic_proto_rawDescGZIP(), []int{0}
}</span>

type PanicResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *PanicResponse) Reset() <span class="cov0" title="0">{
        *x = PanicResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_panic_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PanicResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PanicResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PanicResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_panic_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PanicResponse.ProtoReflect.Descriptor instead.
func (*PanicResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_panic_proto_rawDescGZIP(), []int{1}
}</span>

var File_panic_proto protoreflect.FileDescriptor

var file_panic_proto_rawDesc = []byte{
        0x0a, 0x0b, 0x70, 0x61, 0x6e, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x70,
        0x61, 0x6e, 0x69, 0x63, 0x22, 0x0e, 0x0a, 0x0c, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x22, 0x0f, 0x0a, 0x0d, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0x44, 0x0a, 0x0c, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x34, 0x0a, 0x05, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x12, 0x13,
        0x2e, 0x70, 0x61, 0x6e, 0x69, 0x63, 0x2e, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e, 0x70, 0x61, 0x6e, 0x69, 0x63, 0x2e, 0x50, 0x61, 0x6e, 0x69,
        0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x09, 0x5a, 0x07, 0x2e,
        0x2f, 0x70, 0x61, 0x6e, 0x69, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_panic_proto_rawDescOnce sync.Once
        file_panic_proto_rawDescData = file_panic_proto_rawDesc
)

func file_panic_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_panic_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_panic_proto_rawDescData = protoimpl.X.CompressGZIP(file_panic_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_panic_proto_rawDescData</span>
}

var file_panic_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_panic_proto_goTypes = []interface{}{
        (*PanicRequest)(nil),  // 0: panic.PanicRequest
        (*PanicResponse)(nil), // 1: panic.PanicResponse
}
var file_panic_proto_depIdxs = []int32{
        0, // 0: panic.PanicService.Panic:input_type -&gt; panic.PanicRequest
        1, // 1: panic.PanicService.Panic:output_type -&gt; panic.PanicResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_panic_proto_init() }</span>
func file_panic_proto_init() <span class="cov0" title="0">{
        if File_panic_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_panic_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PanicRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_panic_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PanicResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_panic_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_panic_proto_goTypes,
                DependencyIndexes: file_panic_proto_depIdxs,
                MessageInfos:      file_panic_proto_msgTypes,
        }.Build()
        File_panic_proto = out.File
        file_panic_proto_rawDesc = nil
        file_panic_proto_goTypes = nil
        file_panic_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.6.1
// source: panic.proto

package panic

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PanicServiceClient is the client API for PanicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PanicServiceClient interface {
        Panic(ctx context.Context, in *PanicRequest, opts ...grpc.CallOption) (*PanicResponse, error)
}

type panicServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewPanicServiceClient(cc grpc.ClientConnInterface) PanicServiceClient <span class="cov0" title="0">{
        return &amp;panicServiceClient{cc}
}</span>

func (c *panicServiceClient) Panic(ctx context.Context, in *PanicRequest, opts ...grpc.CallOption) (*PanicResponse, error) <span class="cov0" title="0">{
        out := new(PanicResponse)
        err := c.cc.Invoke(ctx, "/panic.PanicService/Panic", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// PanicServiceServer is the server API for PanicService service.
// All implementations must embed UnimplementedPanicServiceServer
// for forward compatibility
type PanicServiceServer interface {
        Panic(context.Context, *PanicRequest) (*PanicResponse, error)
        mustEmbedUnimplementedPanicServiceServer()
}

// UnimplementedPanicServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPanicServiceServer struct {
}

func (UnimplementedPanicServiceServer) Panic(context.Context, *PanicRequest) (*PanicResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Panic not implemented")
}</span>
func (UnimplementedPanicServiceServer) mustEmbedUnimplementedPanicServiceServer() {<span class="cov0" title="0">}</span>

// UnsafePanicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PanicServiceServer will
// result in compilation errors.
type UnsafePanicServiceServer interface {
        mustEmbedUnimplementedPanicServiceServer()
}

func RegisterPanicServiceServer(s grpc.ServiceRegistrar, srv PanicServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;PanicService_ServiceDesc, srv)
}</span>

func _PanicService_Panic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PanicRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PanicServiceServer).Panic(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/panic.PanicService/Panic",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PanicServiceServer).Panic(ctx, req.(*PanicRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// PanicService_ServiceDesc is the grpc.ServiceDesc for PanicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PanicService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "panic.PanicService",
        HandlerType: (*PanicServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Panic",
                        Handler:    _PanicService_Panic_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "panic.proto",
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package grpc

import (
        "fmt"
        "net"

        "github.com/stefanprodan/podinfo/pkg/api/grpc/echo"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"

        "github.com/stefanprodan/podinfo/pkg/api/grpc/delay"
        "github.com/stefanprodan/podinfo/pkg/api/grpc/env"
        header "github.com/stefanprodan/podinfo/pkg/api/grpc/headers"
        "github.com/stefanprodan/podinfo/pkg/api/grpc/info"
        "github.com/stefanprodan/podinfo/pkg/api/grpc/panic"
        "github.com/stefanprodan/podinfo/pkg/api/grpc/status"
        "github.com/stefanprodan/podinfo/pkg/api/grpc/token"
        "github.com/stefanprodan/podinfo/pkg/api/grpc/version"
)

type Server struct {
        logger *zap.Logger
        config *Config
}

type Config struct {
        Port        int    `mapstructure:"grpc-port"`
        ServiceName string `mapstructure:"grpc-service-name"`

        BackendURL []string `mapstructure:"backend-url"`
        UILogo     string   `mapstructure:"ui-logo"`
        UIMessage  string   `mapstructure:"ui-message"`
        UIColor    string   `mapstructure:"ui-color"`
        UIPath     string   `mapstructure:"ui-path"`
        DataPath   string   `mapstructure:"data-path"`
        ConfigPath string   `mapstructure:"config-path"`
        CertPath   string   `mapstructure:"cert-path"`
        Host       string   `mapstructure:"host"`
        //Port                  string        `mapstructure:"port"`
        SecurePort      string `mapstructure:"secure-port"`
        PortMetrics     int    `mapstructure:"port-metrics"`
        Hostname        string `mapstructure:"hostname"`
        H2C             bool   `mapstructure:"h2c"`
        RandomDelay     bool   `mapstructure:"random-delay"`
        RandomDelayUnit string `mapstructure:"random-delay-unit"`
        RandomDelayMin  int    `mapstructure:"random-delay-min"`
        RandomDelayMax  int    `mapstructure:"random-delay-max"`
        RandomError     bool   `mapstructure:"random-error"`
        Unhealthy       bool   `mapstructure:"unhealthy"`
        Unready         bool   `mapstructure:"unready"`
        JWTSecret       string `mapstructure:"jwt-secret"`
        CacheServer     string `mapstructure:"cache-server"`
}

func NewServer(config *Config, logger *zap.Logger) (*Server, error) <span class="cov0" title="0">{
        srv := &amp;Server{
                logger: logger,
                config: config,
        }

        return srv, nil
}</span>

func (s *Server) ListenAndServe() *grpc.Server <span class="cov0" title="0">{
        listener, err := net.Listen("tcp", fmt.Sprintf(":%v", s.config.Port))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Fatal("failed to listen", zap.Int("port", s.config.Port))
        }</span>

        <span class="cov0" title="0">srv := grpc.NewServer()
        server := health.NewServer()

        // Register grpc apis for reflection
        echo.RegisterEchoServiceServer(srv, &amp;echoServer{config: s.config, logger: s.logger})
        version.RegisterVersionServiceServer(srv, &amp;VersionServer{config: s.config, logger: s.logger})
        panic.RegisterPanicServiceServer(srv, &amp;PanicServer{config: s.config, logger: s.logger})
        delay.RegisterDelayServiceServer(srv, &amp;DelayServer{config: s.config, logger: s.logger})
        header.RegisterHeaderServiceServer(srv, &amp;HeaderServer{config: s.config, logger: s.logger})
        info.RegisterInfoServiceServer(srv, &amp;infoServer{config: s.config})
        status.RegisterStatusServiceServer(srv, &amp;StatusServer{config: s.config, logger: s.logger})
        token.RegisterTokenServiceServer(srv, &amp;TokenServer{config: s.config, logger: s.logger})
        env.RegisterEnvServiceServer(srv, &amp;EnvServer{config: s.config, logger: s.logger})

        reflection.Register(srv)
        grpc_health_v1.RegisterHealthServer(srv, server)
        server.SetServingStatus(s.config.ServiceName, grpc_health_v1.HealthCheckResponse_SERVING)

        go func() </span><span class="cov0" title="0">{
                if err := srv.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        s.logger.Fatal("failed to serve", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">return srv</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package grpc

import (
        "context"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/status"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type StatusServer struct {
        pb.UnimplementedStatusServiceServer
        config *Config
        logger *zap.Logger
}

func (s *StatusServer) Status(ctx context.Context, req *pb.StatusRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        reqCode := req.GetCode()

        grpcCodes := map[string]codes.Code{
                "Ok":                 codes.OK,
                "Canceled":           codes.Canceled,
                "Unknown":            codes.Unknown,
                "InvalidArgument":    codes.InvalidArgument,
                "DeadlineExceeded":   codes.DeadlineExceeded,
                "NotFound":           codes.NotFound,
                "AlreadyExists":      codes.AlreadyExists,
                "PermissionDenied":   codes.PermissionDenied,
                "ResourceExhausted":  codes.ResourceExhausted,
                "FailedPrecondition": codes.FailedPrecondition,
                "Aborted":            codes.Aborted,
                "OutOfRange":         codes.OutOfRange,
                "Unimplemented":      codes.Unimplemented,
                "Internal":           codes.Internal,
                "Unavailable":        codes.Unavailable,
                "DataLoss":           codes.DataLoss,
                "Unauthenticated":    codes.Unauthenticated,
        }

        code, ok := grpcCodes[reqCode]
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unknown, "Unknown status code for more information check https://chromium.googlesource.com/external/github.com/grpc/grpc/+/refs/tags/v1.21.4-pre1/doc/statuscodes.md")
        }</span>

        <span class="cov8" title="1">return &amp;pb.StatusResponse{Status: reqCode}, status.Error(code, "")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.0
// source: status/status.proto

package status

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StatusRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (x *StatusRequest) Reset() <span class="cov0" title="0">{
        *x = StatusRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_status_status_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StatusRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_status_status_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_status_status_proto_rawDescGZIP(), []int{0}
}</span>

func (x *StatusRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatusResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *StatusResponse) Reset() <span class="cov0" title="0">{
        *x = StatusResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_status_status_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_status_status_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_status_status_proto_rawDescGZIP(), []int{1}
}</span>

func (x *StatusResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_status_status_proto protoreflect.FileDescriptor

var file_status_status_proto_rawDesc = []byte{
        0x0a, 0x13, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x23, 0x0a,
        0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12,
        0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f,
        0x64, 0x65, 0x22, 0x28, 0x0a, 0x0e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x32, 0x4a, 0x0a, 0x0d,
        0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x39, 0x0a,
        0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x15, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
        0x2e, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x2f, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_status_status_proto_rawDescOnce sync.Once
        file_status_status_proto_rawDescData = file_status_status_proto_rawDesc
)

func file_status_status_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_status_status_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_status_status_proto_rawDescData = protoimpl.X.CompressGZIP(file_status_status_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_status_status_proto_rawDescData</span>
}

var file_status_status_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_status_status_proto_goTypes = []interface{}{
        (*StatusRequest)(nil),  // 0: status.StatusRequest
        (*StatusResponse)(nil), // 1: status.StatusResponse
}
var file_status_status_proto_depIdxs = []int32{
        0, // 0: status.StatusService.Status:input_type -&gt; status.StatusRequest
        1, // 1: status.StatusService.Status:output_type -&gt; status.StatusResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_status_status_proto_init() }</span>
func file_status_status_proto_init() <span class="cov0" title="0">{
        if File_status_status_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_status_status_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StatusRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_status_status_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StatusResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_status_status_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_status_status_proto_goTypes,
                DependencyIndexes: file_status_status_proto_depIdxs,
                MessageInfos:      file_status_status_proto_msgTypes,
        }.Build()
        File_status_status_proto = out.File
        file_status_status_proto_rawDesc = nil
        file_status_status_proto_goTypes = nil
        file_status_status_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0
// source: status/status.proto

package status

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// StatusServiceClient is the client API for StatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StatusServiceClient interface {
        Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type statusServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewStatusServiceClient(cc grpc.ClientConnInterface) StatusServiceClient <span class="cov0" title="0">{
        return &amp;statusServiceClient{cc}
}</span>

func (c *statusServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov0" title="0">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/status.StatusService/Status", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// StatusServiceServer is the server API for StatusService service.
// All implementations must embed UnimplementedStatusServiceServer
// for forward compatibility
type StatusServiceServer interface {
        Status(context.Context, *StatusRequest) (*StatusResponse, error)
        mustEmbedUnimplementedStatusServiceServer()
}

// UnimplementedStatusServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStatusServiceServer struct {
}

func (UnimplementedStatusServiceServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}</span>
func (UnimplementedStatusServiceServer) mustEmbedUnimplementedStatusServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatusServiceServer will
// result in compilation errors.
type UnsafeStatusServiceServer interface {
        mustEmbedUnimplementedStatusServiceServer()
}

func RegisterStatusServiceServer(s grpc.ServiceRegistrar, srv StatusServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;StatusService_ServiceDesc, srv)
}</span>

func _StatusService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StatusRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(StatusServiceServer).Status(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/status.StatusService/Status",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(StatusServiceServer).Status(ctx, req.(*StatusRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// StatusService_ServiceDesc is the grpc.ServiceDesc for StatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StatusService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "status.StatusService",
        HandlerType: (*StatusServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Status",
                        Handler:    _StatusService_Status_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "status/status.proto",
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package grpc

import (
        "context"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/token"
)

type TokenServer struct {
        pb.UnimplementedTokenServiceServer
        config *Config
        logger *zap.Logger
}

type jwtCustomClaims struct {
        Name string `json:"name"`
        jwt.StandardClaims
}

func (s *TokenServer) TokenGenerate(ctx context.Context, req *pb.TokenRequest) (*pb.TokenResponse, error) <span class="cov8" title="1">{

        user := "anonymous"
        expiresAt := time.Now().Add(time.Minute * 1).Unix()

        claims := &amp;jwtCustomClaims{
                user,
                jwt.StandardClaims{
                        Issuer:    "podinfo",
                        ExpiresAt: expiresAt,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        t, err := token.SignedString([]byte(s.config.JWTSecret))

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to generate token", zap.Error(err))
                return &amp;pb.TokenResponse{}, err
        }</span>

        <span class="cov8" title="1">var result = pb.TokenResponse{
                Token:     t,
                ExpiresAt: time.Unix(claims.StandardClaims.ExpiresAt, 0).String(),
                Message:   "Token generated successfully",
        }

        return &amp;result, nil</span>
}

func (s *TokenServer) TokenValidate(ctx context.Context, req *pb.TokenRequest) (*pb.TokenResponse, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.DataLoss, "UnaryEcho: failed to get metadata")
        }</span>

        <span class="cov0" title="0">authorization := md.Get("authorization")

        if len(authorization) == 0 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unauthenticated, "Authorization token not found in metadata")
        }</span>

        <span class="cov0" title="0">token := strings.TrimSpace(strings.TrimPrefix(authorization[0], "Bearer"))

        claims := jwtCustomClaims{}

        parsed_token, err := jwt.ParseWithClaims(token, &amp;claims, func(parsed_token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := parsed_token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Canceled, "invalid signing method")
                }</span>
                <span class="cov0" title="0">return []byte(s.config.JWTSecret), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "token is expired") || strings.Contains(err.Error(), "signature is invalid") </span><span class="cov0" title="0">{
                        return &amp;pb.TokenResponse{
                                Message: err.Error(),
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, status.Errorf(codes.Unauthenticated, "Unable to parse token")</span>

        }

        <span class="cov0" title="0">if parsed_token.Valid </span><span class="cov0" title="0">{
                if claims.StandardClaims.Issuer != "podinfo" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.OK, "Invalid issuer")
                }</span> else<span class="cov0" title="0"> {
                        var result = pb.TokenResponse{
                                Token:     claims.Name,
                                ExpiresAt: time.Unix(claims.StandardClaims.ExpiresAt, 0).String(),
                        }
                        return &amp;result, nil
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, status.Errorf(codes.Unauthenticated, "Unauthenticated")
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.0
// source: token/token.proto

package token

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TokenRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *TokenRequest) Reset() <span class="cov0" title="0">{
        *x = TokenRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_token_token_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_token_token_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TokenRequest.ProtoReflect.Descriptor instead.
func (*TokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_token_token_proto_rawDescGZIP(), []int{0}
}</span>

type TokenResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token     string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        ExpiresAt string `protobuf:"bytes,2,opt,name=expiresAt,proto3" json:"expiresAt,omitempty"`
        Message   string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *TokenResponse) Reset() <span class="cov0" title="0">{
        *x = TokenResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_token_token_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_token_token_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TokenResponse.ProtoReflect.Descriptor instead.
func (*TokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_token_token_proto_rawDescGZIP(), []int{1}
}</span>

func (x *TokenResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenResponse) GetExpiresAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_token_token_proto protoreflect.FileDescriptor

var file_token_token_proto_rawDesc = []byte{
        0x0a, 0x11, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x12, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x0e, 0x0a, 0x0c, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5d, 0x0a, 0x0d, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74,
        0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65,
        0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12,
        0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x32, 0x8a, 0x01, 0x0a, 0x0c, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x3c, 0x0a, 0x0d, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x12, 0x13, 0x2e, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x14, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3c, 0x0a, 0x0d, 0x54, 0x6f, 0x6b, 0x65,
        0x6e, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x12, 0x13, 0x2e, 0x74, 0x6f, 0x6b, 0x65,
        0x6e, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14,
        0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x09, 0x5a, 0x07, 0x2e, 0x2f, 0x74, 0x6f, 0x6b, 0x65,
        0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_token_token_proto_rawDescOnce sync.Once
        file_token_token_proto_rawDescData = file_token_token_proto_rawDesc
)

func file_token_token_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_token_token_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_token_token_proto_rawDescData = protoimpl.X.CompressGZIP(file_token_token_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_token_token_proto_rawDescData</span>
}

var file_token_token_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_token_token_proto_goTypes = []interface{}{
        (*TokenRequest)(nil),  // 0: token.TokenRequest
        (*TokenResponse)(nil), // 1: token.TokenResponse
}
var file_token_token_proto_depIdxs = []int32{
        0, // 0: token.TokenService.TokenGenerate:input_type -&gt; token.TokenRequest
        0, // 1: token.TokenService.TokenValidate:input_type -&gt; token.TokenRequest
        1, // 2: token.TokenService.TokenGenerate:output_type -&gt; token.TokenResponse
        1, // 3: token.TokenService.TokenValidate:output_type -&gt; token.TokenResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_token_token_proto_init() }</span>
func file_token_token_proto_init() <span class="cov0" title="0">{
        if File_token_token_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_token_token_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TokenRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_token_token_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TokenResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_token_token_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_token_token_proto_goTypes,
                DependencyIndexes: file_token_token_proto_depIdxs,
                MessageInfos:      file_token_token_proto_msgTypes,
        }.Build()
        File_token_token_proto = out.File
        file_token_token_proto_rawDesc = nil
        file_token_token_proto_goTypes = nil
        file_token_token_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0
// source: token/token.proto

package token

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TokenServiceClient is the client API for TokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TokenServiceClient interface {
        TokenGenerate(ctx context.Context, in *TokenRequest, opts ...grpc.CallOption) (*TokenResponse, error)
        TokenValidate(ctx context.Context, in *TokenRequest, opts ...grpc.CallOption) (*TokenResponse, error)
}

type tokenServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTokenServiceClient(cc grpc.ClientConnInterface) TokenServiceClient <span class="cov0" title="0">{
        return &amp;tokenServiceClient{cc}
}</span>

func (c *tokenServiceClient) TokenGenerate(ctx context.Context, in *TokenRequest, opts ...grpc.CallOption) (*TokenResponse, error) <span class="cov0" title="0">{
        out := new(TokenResponse)
        err := c.cc.Invoke(ctx, "/token.TokenService/TokenGenerate", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tokenServiceClient) TokenValidate(ctx context.Context, in *TokenRequest, opts ...grpc.CallOption) (*TokenResponse, error) <span class="cov0" title="0">{
        out := new(TokenResponse)
        err := c.cc.Invoke(ctx, "/token.TokenService/TokenValidate", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TokenServiceServer is the server API for TokenService service.
// All implementations must embed UnimplementedTokenServiceServer
// for forward compatibility
type TokenServiceServer interface {
        TokenGenerate(context.Context, *TokenRequest) (*TokenResponse, error)
        TokenValidate(context.Context, *TokenRequest) (*TokenResponse, error)
        mustEmbedUnimplementedTokenServiceServer()
}

// UnimplementedTokenServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTokenServiceServer struct {
}

func (UnimplementedTokenServiceServer) TokenGenerate(context.Context, *TokenRequest) (*TokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TokenGenerate not implemented")
}</span>
func (UnimplementedTokenServiceServer) TokenValidate(context.Context, *TokenRequest) (*TokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TokenValidate not implemented")
}</span>
func (UnimplementedTokenServiceServer) mustEmbedUnimplementedTokenServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeTokenServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TokenServiceServer will
// result in compilation errors.
type UnsafeTokenServiceServer interface {
        mustEmbedUnimplementedTokenServiceServer()
}

func RegisterTokenServiceServer(s grpc.ServiceRegistrar, srv TokenServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;TokenService_ServiceDesc, srv)
}</span>

func _TokenService_TokenGenerate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TokenServiceServer).TokenGenerate(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/token.TokenService/TokenGenerate",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TokenServiceServer).TokenGenerate(ctx, req.(*TokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TokenService_TokenValidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TokenServiceServer).TokenValidate(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/token.TokenService/TokenValidate",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TokenServiceServer).TokenValidate(ctx, req.(*TokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TokenService_ServiceDesc is the grpc.ServiceDesc for TokenService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TokenService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "token.TokenService",
        HandlerType: (*TokenServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "TokenGenerate",
                        Handler:    _TokenService_TokenGenerate_Handler,
                },
                {
                        MethodName: "TokenValidate",
                        Handler:    _TokenService_TokenValidate_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "token/token.proto",
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package grpc

import (
        "context"

        pb "github.com/stefanprodan/podinfo/pkg/api/grpc/version"
        "github.com/stefanprodan/podinfo/pkg/version"
        "go.uber.org/zap"
)

type VersionServer struct {
        pb.UnimplementedVersionServiceServer
        config *Config
        logger *zap.Logger
}

func (s *VersionServer) Version(ctx context.Context, req *pb.VersionRequest) (*pb.VersionResponse, error) <span class="cov8" title="1">{
        return &amp;pb.VersionResponse{Version: version.VERSION, Commit: version.REVISION}, nil
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v3.6.1
// source: version.proto

package version

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type VersionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *VersionRequest) Reset() <span class="cov0" title="0">{
        *x = VersionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_version_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VersionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VersionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VersionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_version_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VersionRequest.ProtoReflect.Descriptor instead.
func (*VersionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_version_proto_rawDescGZIP(), []int{0}
}</span>

type VersionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
        Commit  string `protobuf:"bytes,2,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (x *VersionResponse) Reset() <span class="cov0" title="0">{
        *x = VersionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_version_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VersionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VersionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VersionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_version_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VersionResponse.ProtoReflect.Descriptor instead.
func (*VersionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_version_proto_rawDescGZIP(), []int{1}
}</span>

func (x *VersionResponse) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VersionResponse) GetCommit() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Commit
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_version_proto protoreflect.FileDescriptor

var file_version_proto_rawDesc = []byte{
        0x0a, 0x0d, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x10, 0x0a, 0x0e, 0x56, 0x65, 0x72, 0x73,
        0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x43, 0x0a, 0x0f, 0x56, 0x65,
        0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a,
        0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
        0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x6d, 0x6d, 0x69,
        0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x32,
        0x50, 0x0a, 0x0e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x3e, 0x0a, 0x07, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x17, 0x2e, 0x76,
        0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e,
        0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
        0x00, 0x42, 0x0b, 0x5a, 0x09, 0x2e, 0x2f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_version_proto_rawDescOnce sync.Once
        file_version_proto_rawDescData = file_version_proto_rawDesc
)

func file_version_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_version_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_version_proto_rawDescData = protoimpl.X.CompressGZIP(file_version_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_version_proto_rawDescData</span>
}

var file_version_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_version_proto_goTypes = []interface{}{
        (*VersionRequest)(nil),  // 0: version.VersionRequest
        (*VersionResponse)(nil), // 1: version.VersionResponse
}
var file_version_proto_depIdxs = []int32{
        0, // 0: version.VersionService.Version:input_type -&gt; version.VersionRequest
        1, // 1: version.VersionService.Version:output_type -&gt; version.VersionResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_version_proto_init() }</span>
func file_version_proto_init() <span class="cov0" title="0">{
        if File_version_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_version_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*VersionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_version_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*VersionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_version_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_version_proto_goTypes,
                DependencyIndexes: file_version_proto_depIdxs,
                MessageInfos:      file_version_proto_msgTypes,
        }.Build()
        File_version_proto = out.File
        file_version_proto_rawDesc = nil
        file_version_proto_goTypes = nil
        file_version_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.6.1
// source: version.proto

package version

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VersionServiceClient is the client API for VersionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionServiceClient interface {
        Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
}

type versionServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewVersionServiceClient(cc grpc.ClientConnInterface) VersionServiceClient <span class="cov0" title="0">{
        return &amp;versionServiceClient{cc}
}</span>

func (c *versionServiceClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) <span class="cov0" title="0">{
        out := new(VersionResponse)
        err := c.cc.Invoke(ctx, "/version.VersionService/Version", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// VersionServiceServer is the server API for VersionService service.
// All implementations must embed UnimplementedVersionServiceServer
// for forward compatibility
type VersionServiceServer interface {
        Version(context.Context, *VersionRequest) (*VersionResponse, error)
        mustEmbedUnimplementedVersionServiceServer()
}

// UnimplementedVersionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVersionServiceServer struct {
}

func (UnimplementedVersionServiceServer) Version(context.Context, *VersionRequest) (*VersionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}</span>
func (UnimplementedVersionServiceServer) mustEmbedUnimplementedVersionServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeVersionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServiceServer will
// result in compilation errors.
type UnsafeVersionServiceServer interface {
        mustEmbedUnimplementedVersionServiceServer()
}

func RegisterVersionServiceServer(s grpc.ServiceRegistrar, srv VersionServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;VersionService_ServiceDesc, srv)
}</span>

func _VersionService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(VersionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VersionServiceServer).Version(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/version.VersionService/Version",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VersionServiceServer).Version(ctx, req.(*VersionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// VersionService_ServiceDesc is the grpc.ServiceDesc for VersionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VersionService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "version.VersionService",
        HandlerType: (*VersionServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Version",
                        Handler:    _VersionService_Version_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "version.proto",
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package http

import (
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/gomodule/redigo/redis"
        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "github.com/stefanprodan/podinfo/pkg/version"
)

// Cache godoc
// @Summary Save payload in cache
// @Description writes the posted content in cache
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param key path string true "Key to save to"
// @Router /cache/{key} [post]
// @Success 202
func (s *Server) cacheWriteHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "cacheWriteHandler")
        defer span.End()

        if s.pool == nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "cache server is offline", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">key := mux.Vars(r)["key"]
        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "reading the request body failed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">conn := s.pool.Get()
        defer conn.Close()
        _, err = conn.Do("SET", key, string(body))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("cache set failed", zap.Error(err))
                s.ErrorResponse(w, r, span, "cache set failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusAccepted)</span>
}

// Cache godoc
// @Summary Delete payload from cache
// @Description deletes the key and its value from cache
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param key path string true "Key to delete"
// @Router /cache/{key} [delete]
// @Success 202
func (s *Server) cacheDeleteHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "cacheDeleteHandler")
        defer span.End()

        if s.pool == nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "cache server is offline", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">key := mux.Vars(r)["key"]

        conn := s.pool.Get()
        defer conn.Close()
        _, err := conn.Do("DEL", key)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("cache delete failed", zap.Error(err))
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusAccepted)</span>
}

// Cache godoc
// @Summary Get payload from cache
// @Description returns the content from cache if key exists
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param key path string true "Key to load from cache"
// @Router /cache/{key} [get]
// @Success 200 {string} string value
func (s *Server) cacheReadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "cacheReadHandler")
        defer span.End()

        if s.pool == nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "cache server is offline", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">key := mux.Vars(r)["key"]

        conn := s.pool.Get()
        defer conn.Close()

        ok, err := redis.Bool(conn.Do("EXISTS", key))
        if err != nil || !ok </span><span class="cov0" title="0">{
                s.logger.Warn("cache key not found", zap.String("key", key))
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">data, err := redis.String(conn.Do("GET", key))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("cache get failed", zap.Error(err))
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte(data))</span>
}

func (s *Server) getCacheConn() (redis.Conn, error) <span class="cov0" title="0">{
        redisUrl, err := url.Parse(s.config.CacheServer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse redis url: %v", err)
        }</span>

        <span class="cov0" title="0">var opts []redis.DialOption
        if user := redisUrl.User; user != nil </span><span class="cov0" title="0">{
                opts = append(opts, redis.DialUsername(user.Username()))
                if password, ok := user.Password(); ok </span><span class="cov0" title="0">{
                        opts = append(opts, redis.DialPassword(password))
                }</span>
        }

        <span class="cov0" title="0">return redis.Dial("tcp", redisUrl.Host, opts...)</span>
}

func (s *Server) startCachePool(ticker *time.Ticker) <span class="cov0" title="0">{
        if s.config.CacheServer == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.pool = &amp;redis.Pool{
                MaxIdle:     3,
                IdleTimeout: 240 * time.Second,
                Dial:        s.getCacheConn,
                TestOnBorrow: func(c redis.Conn, t time.Time) error </span><span class="cov0" title="0">{
                        _, err := c.Do("PING")
                        return err
                }</span>,
        }

        // set &lt;hostname&gt;=&lt;version&gt; with an expiry time of one minute
        <span class="cov0" title="0">setVersion := func() </span><span class="cov0" title="0">{
                conn := s.pool.Get()
                if _, err := conn.Do("SET", s.config.Hostname, version.VERSION, "EX", 60); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("cache server is offline", zap.Error(err), zap.String("server", s.config.CacheServer))
                }</span>
                <span class="cov0" title="0">_ = conn.Close()</span>
        }

        // set version on a schedule
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                setVersion()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                setVersion()</span>
                        }
                }
        }()
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package http

import (
        "math/rand"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
)

// Chunked godoc
// @Summary Chunked transfer encoding
// @Description uses transfer-encoding type chunked to give a partial response and then waits for the specified period
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param seconds path int true "seconds to wait for"
// @Router /chunked/{seconds} [get]
// @Success 200 {object} http.MapResponse
func (s *Server) chunkedHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, span := s.tracer.Start(r.Context(), "chunkedHandler")
        defer span.End()

        vars := mux.Vars(r)

        delay, err := strconv.Atoi(vars["wait"])
        if err != nil </span><span class="cov0" title="0">{
                delay = rand.Intn(int(s.config.HttpServerTimeout*time.Second)-10) + 10
        }</span>

        <span class="cov8" title="1">flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "Streaming unsupported!", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Connection", "Keep-Alive")
        w.Header().Set("Transfer-Encoding", "chunked")
        w.Header().Set("X-Content-Type-Options", "nosniff")

        flusher.Flush()

        time.Sleep(time.Duration(delay) * time.Second)
        s.JSONResponse(w, r, map[string]int{"delay": delay})

        flusher.Flush()</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package http

import "net/http"

func (s *Server) configReadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "configReadHandler")
        defer span.End()

        files := make(map[string]string)
        if watcher != nil </span><span class="cov0" title="0">{
                watcher.Cache.Range(func(key interface{}, value interface{}) bool </span><span class="cov0" title="0">{
                        files[key.(string)] = value.(string)
                        return true
                }</span>)
        }

        <span class="cov0" title="0">s.JSONResponse(w, r, files)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package http

import (
        "context"
        "fmt"
        "math/rand"
        "net/http"
        "sync"
        "strconv"
        "time"

        "github.com/gorilla/mux"
)

type RandomDelayMiddleware struct {
        min  int
        max  int
        unit string
}

// Job represents a long-running operation that can be cancelled
type Job struct {
        ID        string
        Status    string // "running", "cancelled", "completed"
        StartTime time.Time
        Cancel    context.CancelFunc
}

// JobManager manages active jobs and their cancellation
type JobManager struct {
        jobs map[string]*Job
        mux  sync.RWMutex
}

var jobManager = &amp;JobManager{
        jobs: make(map[string]*Job),
}

// AddJob adds a new job to the manager
func (jm *JobManager) AddJob(job *Job) <span class="cov8" title="1">{
        jm.mux.Lock()
        defer jm.mux.Unlock()
        jm.jobs[job.ID] = job
}</span>

// GetJob retrieves a job by ID
func (jm *JobManager) GetJob(id string) (*Job, bool) <span class="cov0" title="0">{
        jm.mux.RLock()
        defer jm.mux.RUnlock()
        job, exists := jm.jobs[id]
        return job, exists
}</span>

// CancelJob cancels a job by ID
func (jm *JobManager) CancelJob(id string) bool <span class="cov0" title="0">{
        jm.mux.Lock()
        defer jm.mux.Unlock()
        job, exists := jm.jobs[id]
        if exists &amp;&amp; job.Status == "running" </span><span class="cov0" title="0">{
                job.Status = "cancelled"
                job.Cancel()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RemoveJob removes a completed job
func (jm *JobManager) RemoveJob(id string) <span class="cov8" title="1">{
        jm.mux.Lock()
        defer jm.mux.Unlock()
        delete(jm.jobs, id)
}</span>

// GetAllJobs returns all active jobs
func (jm *JobManager) GetAllJobs() map[string]*Job <span class="cov0" title="0">{
        jm.mux.RLock()
        defer jm.mux.RUnlock()
        jobs := make(map[string]*Job)
        for k, v := range jm.jobs </span><span class="cov0" title="0">{
                jobs[k] = v
        }</span>
        <span class="cov0" title="0">return jobs</span>
}

func NewRandomDelayMiddleware(minDelay, maxDelay int, delayUnit string) *RandomDelayMiddleware <span class="cov0" title="0">{
        return &amp;RandomDelayMiddleware{
                min:  minDelay,
                max:  maxDelay,
                unit: delayUnit,
        }
}</span>

func (m *RandomDelayMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var unit time.Duration
                rand.Seed(time.Now().Unix())
                switch m.unit </span>{
                case "s":<span class="cov0" title="0">
                        unit = time.Second</span>
                case "ms":<span class="cov0" title="0">
                        unit = time.Millisecond</span>
                default:<span class="cov0" title="0">
                        unit = time.Second</span>
                }

                <span class="cov0" title="0">delay := rand.Intn(m.max-m.min) + m.min
                time.Sleep(time.Duration(delay) * unit)
                next.ServeHTTP(w, r)</span>
        })
}

// Delay godoc
// @Summary Delay
// @Description waits for the specified period
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param seconds path int true "seconds to wait for"
// @Router /delay/{seconds} [get]
// @Success 200 {object} http.MapResponse
func (s *Server) delayHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, span := s.tracer.Start(r.Context(), "delayHandler")
        defer span.End()

        vars := mux.Vars(r)

        delay, err := strconv.Atoi(vars["wait"])
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Create a cancellable context
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(r.Context())
        defer cancel()

        // Generate a unique job ID
        jobID := generateJobID()
        job := &amp;Job{
                ID:        jobID,
                Status:    "running",
                StartTime: time.Now(),
                Cancel:    cancel,
        }

        // Add job to manager
        jobManager.AddJob(job)
        defer jobManager.RemoveJob(jobID)

        // Use a ticker to check for cancellation periodically
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        remainingDelay := time.Duration(delay) * time.Second
        startTime := time.Now()

        for remainingDelay &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Job was cancelled
                        job.Status = "cancelled"
                        s.JSONResponse(w, r, map[string]interface{}{
                                "delay":     delay,
                                "status":    "cancelled",
                                "job_id":    jobID,
                                "completed": time.Since(startTime).Seconds(),
                        })
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if job was cancelled externally
                        if job.Status == "cancelled" </span><span class="cov0" title="0">{
                                s.JSONResponse(w, r, map[string]interface{}{
                                        "delay":     delay,
                                        "status":    "cancelled",
                                        "job_id":    jobID,
                                        "completed": time.Since(startTime).Seconds(),
                                })
                                return
                        }</span>
                        // Continue with a small delay
                        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)
                        remainingDelay -= 100 * time.Millisecond</span>
                }
        }

        // Job completed successfully
        <span class="cov8" title="1">job.Status = "completed"
        s.JSONResponse(w, r, map[string]interface{}{
                "delay":     delay,
                "status":    "completed",
                "job_id":    jobID,
                "completed": time.Since(startTime).Seconds(),
        })</span>
}

// generateJobID creates a unique job identifier
func generateJobID() string <span class="cov8" title="1">{
        return fmt.Sprintf("job_%d_%d", time.Now().Unix(), rand.Intn(10000))
}</span>

// CancelJob godoc
// @Summary Cancel Job
// @Description cancels a running job by ID
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param id path string true "job ID to cancel"
// @Router /jobs/{id}/cancel [post]
// @Success 200 {object} http.MapResponse
func (s *Server) cancelJobHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "cancelJobHandler")
        defer span.End()

        vars := mux.Vars(r)
        jobID := vars["id"]

        success := jobManager.CancelJob(jobID)
        if success </span><span class="cov0" title="0">{
                s.JSONResponse(w, r, map[string]interface{}{
                        "status": "cancelled",
                        "job_id": jobID,
                })
        }</span> else<span class="cov0" title="0"> {
                s.ErrorResponse(w, r, span, "Job not found or already completed", http.StatusNotFound)
        }</span>
}

// ListJobs godoc
// @Summary List Jobs
// @Description lists all active jobs
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /jobs [get]
// @Success 200 {object} http.MapResponse
func (s *Server) listJobsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "listJobsHandler")
        defer span.End()

        jobs := jobManager.GetAllJobs()
        jobList := make([]map[string]interface{}, 0, len(jobs))
        
        for _, job := range jobs </span><span class="cov0" title="0">{
                jobList = append(jobList, map[string]interface{}{
                        "id":         job.ID,
                        "status":     job.Status,
                        "start_time": job.StartTime,
                        "duration":   time.Since(job.StartTime).Seconds(),
                })
        }</span>

        <span class="cov0" title="0">s.JSONResponse(w, r, map[string]interface{}{
                "jobs":  jobList,
                "count": len(jobList),
        })</span>
}

// GetJob godoc
// @Summary Get Job
// @Description gets job details by ID
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param id path string true "job ID"
// @Router /jobs/{id} [get]
// @Success 200 {object} http.MapResponse
func (s *Server) getJobHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "getJobHandler")
        defer span.End()

        vars := mux.Vars(r)
        jobID := vars["id"]

        job, exists := jobManager.GetJob(jobID)
        if !exists </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "Job not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">s.JSONResponse(w, r, map[string]interface{}{
                "id":         job.ID,
                "status":     job.Status,
                "start_time": job.StartTime,
                "duration":   time.Since(job.StartTime).Seconds(),
        })</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Source Code",
            "url": "https://github.com/stefanprodan/podinfo"
        },
        "license": {
            "name": "MIT License",
            "url": "https://github.com/stefanprodan/podinfo/blob/master/LICENSE"
        },
        "version": "{{.Version}}"
    },
    "basePath": "{{.BasePath}}",
    "paths": {
        "/": {
            "get": {
                "description": "renders podinfo UI",
                "produces": [
                    "text/html"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Index",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/echo": {
            "post": {
                "description": "forwards the call to the backend service and echos the posted content",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Echo",
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        },
        "/api/info": {
            "get": {
                "description": "returns the runtime information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Runtime information",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.RuntimeResponse"
                        }
                    }
                }
            }
        },
        "/cache/{key}": {
            "get": {
                "description": "returns the content from cache if key exists",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Get payload from cache",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Key to load from cache",
                        "name": "key",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            },
            "post": {
                "description": "writes the posted content in cache",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Save payload in cache",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Key to save to",
                        "name": "key",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted"
                    }
                }
            },
            "delete": {
                "description": "deletes the key and its value from cache",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Delete payload from cache",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Key to delete",
                        "name": "key",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted"
                    }
                }
            }
        },
        "/chunked/{seconds}": {
            "get": {
                "description": "uses transfer-encoding type chunked to give a partial response and then waits for the specified period",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Chunked transfer encoding",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "seconds to wait for",
                        "name": "seconds",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        },
        "/delay/{seconds}": {
            "get": {
                "description": "waits for the specified period",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Delay",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "seconds to wait for",
                        "name": "seconds",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        },
        "/env": {
            "get": {
                "description": "returns the environment variables as a JSON array",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Environment",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/headers": {
            "get": {
                "description": "returns a JSON array with the request HTTP headers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Headers",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/healthz": {
            "get": {
                "description": "used by Kubernetes liveness probe",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Kubernetes"
                ],
                "summary": "Liveness check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/metrics": {
            "get": {
                "description": "returns HTTP requests duration and Go runtime metrics",
                "produces": [
                    "text/plain"
                ],
                "tags": [
                    "Kubernetes"
                ],
                "summary": "Prometheus metrics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/panic": {
            "get": {
                "description": "crashes the process with exit code 255",
                "tags": [
                    "HTTP API"
                ],
                "summary": "Panic",
                "responses": {}
            }
        },
        "/readyz": {
            "get": {
                "description": "used by Kubernetes readiness probe",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Kubernetes"
                ],
                "summary": "Readiness check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/readyz/disable": {
            "post": {
                "description": "signals the Kubernetes LB to stop sending requests to this instance",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Kubernetes"
                ],
                "summary": "Disable ready state",
                "responses": {
                    "202": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/readyz/enable": {
            "post": {
                "description": "signals the Kubernetes LB that this instance is ready to receive traffic",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Kubernetes"
                ],
                "summary": "Enable ready state",
                "responses": {
                    "202": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/status/{code}": {
            "get": {
                "description": "sets the response status code to the specified code",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Status code",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "status code to return",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        },
        "/store": {
            "post": {
                "description": "writes the posted content to disk at /data/hash and returns the SHA1 hash of the content",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Upload file",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        },
        "/store/{hash}": {
            "get": {
                "description": "returns the content of the file /data/hash if exists",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "text/plain"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Download file",
                "parameters": [
                    {
                        "type": "string",
                        "description": "hash value",
                        "name": "hash",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "file",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/token": {
            "post": {
                "description": "issues a JWT token valid for one minute",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Generate JWT token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.TokenResponse"
                        }
                    }
                }
            }
        },
        "/token/validate": {
            "post": {
                "description": "validates the JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Validate JWT token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.TokenValidationResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/version": {
            "get": {
                "description": "returns podinfo version and git commit hash",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Version",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        },
        "/ws/echo": {
            "post": {
                "description": "echos content via websockets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HTTP API"
                ],
                "summary": "Echo over websockets",
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/http.MapResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "http.MapResponse": {
            "type": "object",
            "additionalProperties": {
                "type": "string"
            }
        },
        "http.RuntimeResponse": {
            "type": "object",
            "properties": {
                "color": {
                    "type": "string"
                },
                "goarch": {
                    "type": "string"
                },
                "goos": {
                    "type": "string"
                },
                "hostname": {
                    "type": "string"
                },
                "logo": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "num_cpu": {
                    "type": "string"
                },
                "num_goroutine": {
                    "type": "string"
                },
                "revision": {
                    "type": "string"
                },
                "runtime": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "http.TokenResponse": {
            "type": "object",
            "properties": {
                "expires_at": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "http.TokenValidationResponse": {
            "type": "object",
            "properties": {
                "expires_at": {
                    "type": "string"
                },
                "token_name": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "2.0",
        Host:             "",
        BasePath:         "/",
        Schemes:          []string{"http", "https"},
        Title:            "Podinfo API",
        Description:      "Go microservice template for Kubernetes.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package http

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "net/http/httptrace"
        "sync"

        "github.com/stefanprodan/podinfo/pkg/version"
        "go.opentelemetry.io/contrib/instrumentation/net/http/httptrace/otelhttptrace"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        "go.uber.org/zap"
)

// Echo godoc
// @Summary Echo
// @Description forwards the call to the backend service and echos the posted content
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /api/echo [post]
// @Success 202 {object} http.MapResponse
func (s *Server) echoHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx, span := s.tracer.Start(r.Context(), "echoHandler")
        defer span.End()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("reading the request body failed", zap.Error(err))
                s.ErrorResponse(w, r, span, "invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        client := http.Client{Transport: otelhttp.NewTransport(http.DefaultTransport)}

        if len(s.config.BackendURL) &gt; 0 </span><span class="cov0" title="0">{
                result := make([]string, len(s.config.BackendURL))
                var wg sync.WaitGroup
                wg.Add(len(s.config.BackendURL))
                for i, b := range s.config.BackendURL </span><span class="cov0" title="0">{
                        go func(index int, backend string) </span><span class="cov0" title="0">{
                                defer wg.Done()

                                ctx = httptrace.WithClientTrace(ctx, otelhttptrace.NewClientTrace(ctx))
                                ctx, cancel := context.WithTimeout(ctx, s.config.HttpClientTimeout)
                                defer cancel()

                                backendReq, err := http.NewRequestWithContext(ctx, "POST", backend, bytes.NewReader(body))
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("backend call failed", zap.Error(err), zap.String("url", backend))
                                        return
                                }</span>

                                // forward headers
                                <span class="cov0" title="0">copyTracingHeaders(r, backendReq)

                                backendReq.Header.Set("X-API-Version", version.VERSION)
                                backendReq.Header.Set("X-API-Revision", version.REVISION)

                                // call backend
                                resp, err := client.Do(backendReq)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("backend call failed", zap.Error(err), zap.String("url", backend))
                                        result[index] = fmt.Sprintf("backend %v call failed %v", backend, err)
                                        return
                                }</span>
                                <span class="cov0" title="0">defer resp.Body.Close()

                                // copy error status from backend and exit
                                if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                        s.logger.Error("backend call failed", zap.Int("status", resp.StatusCode), zap.String("url", backend))
                                        result[index] = fmt.Sprintf("backend %v response status code %v", backend, resp.StatusCode)
                                        return
                                }</span>

                                // forward the received body
                                <span class="cov0" title="0">rbody, err := io.ReadAll(resp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error(
                                                "reading the backend request body failed",
                                                zap.Error(err),
                                                zap.String("url", backend))
                                        result[index] = fmt.Sprintf("backend %v call failed %v", backend, err)
                                        return
                                }</span>

                                <span class="cov0" title="0">s.logger.Debug(
                                        "payload received from backend",
                                        zap.String("response", string(rbody)),
                                        zap.String("url", backend))

                                result[index] = string(rbody)</span>
                        }(i, b)
                }
                <span class="cov0" title="0">wg.Wait()

                w.Header().Set("X-Color", s.config.UIColor)
                s.JSONResponse(w, r, result)</span>

        } else<span class="cov8" title="1"> {
                w.Header().Set("X-Color", s.config.UIColor)
                w.WriteHeader(http.StatusAccepted)
                w.Write(body)
        }</span>
}

func copyTracingHeaders(from *http.Request, to *http.Request) <span class="cov0" title="0">{
        headers := []string{
                "x-request-id",
                "x-b3-traceid",
                "x-b3-spanid",
                "x-b3-parentspanid",
                "x-b3-sampled",
                "x-b3-flags",
                "x-ot-span-context",
        }

        for i := range headers </span><span class="cov0" title="0">{
                headerValue := from.Header.Get(headers[i])
                if len(headerValue) &gt; 0 </span><span class="cov0" title="0">{
                        to.Header.Set(headers[i], headerValue)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package http

import (
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

var wsCon = websocket.Upgrader{}

// EchoWS godoc
// @Summary Echo over websockets
// @Description echos content via websockets
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /ws/echo [post]
// @Success 202 {object} http.MapResponse
// Test: go run ./cmd/podcli/* ws localhost:9898/ws/echo
func (s *Server) echoWsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        c, err := wsCon.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("websocket upgrade error", zap.Error(err))
                        return
                }</span>
        }
        <span class="cov0" title="0">var wg sync.WaitGroup
        wg.Add(1)

        defer c.Close()
        done := make(chan struct{})
        defer close(done)
        in := make(chan interface{})
        go s.writeWs(c, in)
        go s.sendHostWs(c, in, done, &amp;wg)
        go func() </span><span class="cov0" title="0">{
                defer close(in)
                wg.Wait()
        }</span>()
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if !strings.Contains(err.Error(), "close") </span><span class="cov0" title="0">{
                                s.logger.Warn("websocket read error", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">var response = struct {
                        Time    time.Time `json:"ts"`
                        Message string    `json:"msg"`
                }{
                        Time:    time.Now(),
                        Message: string(message),
                }
                in &lt;- response</span>
        }
}

func (s *Server) sendHostWs(ws *websocket.Conn, in chan interface{}, done chan struct{}, wg *sync.WaitGroup) <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        var status = struct {
                                Time time.Time `json:"ts"`
                                Host string    `json:"server"`
                        }{
                                Time: time.Now(),
                                Host: s.config.Hostname,
                        }
                        in &lt;- status</span>
                case &lt;-done:<span class="cov0" title="0">
                        s.logger.Debug("websocket exit")
                        wg.Done()
                        return</span>
                }
        }
}

func (s *Server) writeWs(ws *websocket.Conn, in chan interface{}) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-in:<span class="cov0" title="0">
                        if err := ws.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                                if !strings.Contains(err.Error(), "close") </span><span class="cov0" title="0">{
                                        s.logger.Warn("websocket write error", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package http

import (
        "net/http"

        "os"
)

// Env godoc
// @Summary Environment
// @Description returns the environment variables as a JSON array
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /env [get]
// @Success 200 {object} http.ArrayResponse
func (s *Server) envHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "envHandler")
        defer span.End()
        s.JSONResponse(w, r, os.Environ())
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package http

import (
        "net/http"
)

// Headers godoc
// @Summary Headers
// @Description returns a JSON array with the request HTTP headers
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /headers [get]
// @Success 200 {object} http.ArrayResponse
func (s *Server) echoHeadersHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, span := s.tracer.Start(r.Context(), "echoHeadersHandler")
        defer span.End()
        s.JSONResponse(w, r, r.Header)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package http

import (
        "net/http"
        "sync/atomic"
)

// Healthz godoc
// @Summary Liveness check
// @Description used by Kubernetes liveness probe
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /healthz [get]
// @Success 200 {string} string "OK"
func (s *Server) healthzHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;healthy) == 1 </span><span class="cov0" title="0">{
                s.JSONResponse(w, r, map[string]string{"status": "OK"})
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusServiceUnavailable)</span>
}

// Readyz godoc
// @Summary Readiness check
// @Description used by Kubernetes readiness probe
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /readyz [get]
// @Success 200 {string} string "OK"
func (s *Server) readyzHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;ready) == 1 </span><span class="cov0" title="0">{
                s.JSONResponse(w, r, map[string]string{"status": "OK"})
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusServiceUnavailable)</span>
}

// EnableReady godoc
// @Summary Enable ready state
// @Description signals the Kubernetes LB that this instance is ready to receive traffic
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /readyz/enable [post]
// @Success 202 {string} string "OK"
func (s *Server) enableReadyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;ready, 1)
        w.WriteHeader(http.StatusAccepted)
}</span>

// DisableReady godoc
// @Summary Disable ready state
// @Description signals the Kubernetes LB to stop sending requests to this instance
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /readyz/disable [post]
// @Success 202 {string} string "OK"
func (s *Server) disableReadyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;ready, 0)
        w.WriteHeader(http.StatusAccepted)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package http

import (
        "bytes"
        "encoding/json"
        "math/rand"
        "net/http"
        "time"

        "github.com/stefanprodan/podinfo/pkg/version"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
)

func randomErrorMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                rand.Seed(time.Now().Unix())
                if rand.Int31n(3) == 0 </span><span class="cov0" title="0">{

                        errors := []int{http.StatusInternalServerError, http.StatusBadRequest, http.StatusConflict}
                        w.WriteHeader(errors[rand.Intn(len(errors))])
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func versionMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                r.Header.Set("X-API-Version", version.VERSION)
                r.Header.Set("X-API-Revision", version.REVISION)

                next.ServeHTTP(w, r)
        }</span>)
}

func (s *Server) JSONResponse(w http.ResponseWriter, r *http.Request, result interface{}) <span class="cov8" title="1">{
        body, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                s.logger.Error("JSON marshal failed", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(http.StatusOK)
        w.Write(prettyJSON(body))</span>
}

func (s *Server) JSONResponseCode(w http.ResponseWriter, r *http.Request, result interface{}, responseCode int) <span class="cov8" title="1">{
        body, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                s.logger.Error("JSON marshal failed", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(responseCode)
        w.Write(prettyJSON(body))</span>
}

func (s *Server) ErrorResponse(w http.ResponseWriter, r *http.Request, span trace.Span, error string, code int) <span class="cov0" title="0">{
        data := struct {
                Code    int    `json:"code"`
                Message string `json:"message"`
        }{
                Code:    code,
                Message: error,
        }

        span.SetStatus(codes.Error, error)

        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                s.logger.Error("JSON marshal failed", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(http.StatusOK)
        w.Write(prettyJSON(body))</span>
}

func prettyJSON(b []byte) []byte <span class="cov8" title="1">{
        var out bytes.Buffer
        json.Indent(&amp;out, b, "", "  ")
        return out.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package http

import (
        "html/template"
        "net/http"
        "path"
)

// Index godoc
// @Summary Index
// @Description renders podinfo UI
// @Tags HTTP API
// @Produce html
// @Router / [get]
// @Success 200 {string} string "OK"
func (s *Server) indexHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "indexHandler")
        defer span.End()

        tmpl, err := template.New("vue.html").ParseFiles(path.Join(s.config.UIPath, "vue.html"))
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte(path.Join(s.config.UIPath, "vue.html") + err.Error()))
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
                Logo  string
        }{
                Title: s.config.Hostname,
                Logo:  s.config.UILogo,
        }

        if err := tmpl.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, path.Join(s.config.UIPath, "vue.html")+err.Error(), http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package http

import (
        "net/http"

        "runtime"
        "strconv"

        "github.com/stefanprodan/podinfo/pkg/version"
)

// Info godoc
// @Summary Runtime information
// @Description returns the runtime information
// @Tags HTTP API
// @Accept json
// @Produce json
// @Success 200 {object} http.RuntimeResponse
// @Router /api/info [get]
func (s *Server) infoHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, span := s.tracer.Start(r.Context(), "infoHandler")
        defer span.End()

        data := RuntimeResponse{
                Hostname:     s.config.Hostname,
                Version:      version.VERSION,
                Revision:     version.REVISION,
                Logo:         s.config.UILogo,
                Color:        s.config.UIColor,
                Message:      s.config.UIMessage,
                GOOS:         runtime.GOOS,
                GOARCH:       runtime.GOARCH,
                Runtime:      runtime.Version(),
                NumGoroutine: strconv.FormatInt(int64(runtime.NumGoroutine()), 10),
                NumCPU:       strconv.FormatInt(int64(runtime.NumCPU()), 10),
        }

        s.JSONResponse(w, r, data)
}</span>

type RuntimeResponse struct {
        Hostname     string `json:"hostname"`
        Version      string `json:"version"`
        Revision     string `json:"revision"`
        Color        string `json:"color"`
        Logo         string `json:"logo"`
        Message      string `json:"message"`
        GOOS         string `json:"goos"`
        GOARCH       string `json:"goarch"`
        Runtime      string `json:"runtime"`
        NumGoroutine string `json:"num_goroutine"`
        NumCPU       string `json:"num_cpu"`
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package http

import (
        "net/http"

        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
)

type LoggingMiddleware struct {
        logger *zap.Logger
}

func NewLoggingMiddleware(logger *zap.Logger) *LoggingMiddleware <span class="cov0" title="0">{
        return &amp;LoggingMiddleware{
                logger: logger,
        }
}</span>

func (m *LoggingMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fields := []zap.Field{
                        zap.String("proto", r.Proto),
                        zap.String("uri", r.RequestURI),
                        zap.String("method", r.Method),
                        zap.String("remote", r.RemoteAddr),
                        zap.String("user-agent", r.UserAgent()),
                }

                spanCtx := trace.SpanContextFromContext(r.Context())
                if spanCtx.HasTraceID() </span><span class="cov0" title="0">{
                        fields = append(fields, zap.String("trace_id", spanCtx.TraceID().String()))
                }</span>

                <span class="cov0" title="0">m.logger.Debug(
                        "request started",
                        fields...,
                )
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package http

import (
        "bufio"
        "fmt"
        "io"
        "net"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus"
)

type PrometheusMiddleware struct {
        Histogram *prometheus.HistogramVec
        Counter   *prometheus.CounterVec
}

func NewPrometheusMiddleware() *PrometheusMiddleware <span class="cov0" title="0">{
        // used for monitoring and alerting (RED method)
        histogram := prometheus.NewHistogramVec(prometheus.HistogramOpts{
                Subsystem: "http",
                Name:      "request_duration_seconds",
                Help:      "Seconds spent serving HTTP requests.",
                Buckets:   prometheus.DefBuckets,
        }, []string{"method", "path", "status"})
        // used for horizontal pod auto-scaling (Kubernetes HPA v2)
        counter := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Subsystem: "http",
                        Name:      "requests_total",
                        Help:      "The total number of HTTP requests.",
                },
                []string{"status"},
        )

        prometheus.MustRegister(histogram)
        prometheus.MustRegister(counter)

        return &amp;PrometheusMiddleware{
                Histogram: histogram,
                Counter:   counter,
        }
}</span>

// Metrics godoc
// @Summary Prometheus metrics
// @Description returns HTTP requests duration and Go runtime metrics
// @Tags Kubernetes
// @Produce plain
// @Router /metrics [get]
// @Success 200 {string} string "OK"
func (p *PrometheusMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                begin := time.Now()
                interceptor := &amp;interceptor{ResponseWriter: w, statusCode: http.StatusOK}
                path := p.getRouteName(r)
                next.ServeHTTP(interceptor.wrappedResponseWriter(), r)
                var (
                        status = strconv.Itoa(interceptor.statusCode)
                        took   = time.Since(begin)
                )
                p.Histogram.WithLabelValues(r.Method, path, status).Observe(took.Seconds())
                p.Counter.WithLabelValues(status).Inc()
        }</span>)
}

// converts gorilla mux routes from '/api/delay/{wait}' to 'api_delay_wait'
func (p *PrometheusMiddleware) getRouteName(r *http.Request) string <span class="cov0" title="0">{
        if mux.CurrentRoute(r) != nil </span><span class="cov0" title="0">{
                if name := mux.CurrentRoute(r).GetName(); len(name) &gt; 0 </span><span class="cov0" title="0">{
                        return urlToLabel(name)
                }</span>
                <span class="cov0" title="0">if path, err := mux.CurrentRoute(r).GetPathTemplate(); err == nil </span><span class="cov0" title="0">{
                        if len(path) &gt; 0 </span><span class="cov0" title="0">{
                                return urlToLabel(path)
                        }</span>
                }
        }
        <span class="cov0" title="0">return urlToLabel(r.RequestURI)</span>
}

var invalidChars = regexp.MustCompile(`[^a-zA-Z0-9]+`)

// converts a URL path to a string compatible with Prometheus label value.
func urlToLabel(path string) string <span class="cov0" title="0">{
        result := invalidChars.ReplaceAllString(path, "_")
        result = strings.ToLower(strings.Trim(result, "_"))
        if result == "" </span><span class="cov0" title="0">{
                result = "root"
        }</span>
        <span class="cov0" title="0">return result</span>
}

type interceptor struct {
        http.ResponseWriter
        statusCode int
        recorded   bool
}

func (i *interceptor) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        hj, ok := i.ResponseWriter.(http.Hijacker)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("interceptor: can't cast parent ResponseWriter to Hijacker")
        }</span>
        <span class="cov0" title="0">return hj.Hijack()</span>
}

func (i *interceptor) WriteHeader(code int) <span class="cov0" title="0">{
        if !i.recorded </span><span class="cov0" title="0">{
                i.statusCode = code
                i.recorded = true
        }</span>
        <span class="cov0" title="0">i.ResponseWriter.WriteHeader(code)</span>
}

// Returns a wrapped http.ResponseWriter that implements the same optional interfaces
// that the underlying ResponseWriter has.
// Handle every possible combination so that code that checks for the existence of each
// optional interface functions properly.
// Based on https://github.com/felixge/httpsnoop/blob/eadd4fad6aac69ae62379194fe0219f3dbc80fd3/wrap_generated_gteq_1.8.go#L66
func (i *interceptor) wrappedResponseWriter() http.ResponseWriter <span class="cov0" title="0">{
        closeNotifier, isCloseNotifier := i.ResponseWriter.(http.CloseNotifier)
        flush, isFlusher := i.ResponseWriter.(http.Flusher)
        hijack, isHijacker := i.ResponseWriter.(http.Hijacker)
        push, isPusher := i.ResponseWriter.(http.Pusher)
        readFrom, isReaderFrom := i.ResponseWriter.(io.ReaderFrom)

        switch </span>{
        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                }{i}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                }{i, closeNotifier}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                }{i, flush}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                }{i, hijack}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Pusher
                }{i, push}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        io.ReaderFrom
                }{i, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                }{i, closeNotifier, flush}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                }{i, closeNotifier, hijack}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Pusher
                }{i, closeNotifier, push}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        io.ReaderFrom
                }{i, closeNotifier, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                }{i, flush, hijack}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Pusher
                }{i, flush, push}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        io.ReaderFrom
                }{i, flush, readFrom}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                        http.Pusher
                }{i, hijack, push}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                        io.ReaderFrom
                }{i, hijack, readFrom}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Pusher
                        io.ReaderFrom
                }{i, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                }{i, closeNotifier, flush, hijack}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Pusher
                }{i, closeNotifier, flush, push}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        io.ReaderFrom
                }{i, closeNotifier, flush, readFrom}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                        http.Pusher
                }{i, closeNotifier, hijack, push}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                        io.ReaderFrom
                }{i, closeNotifier, hijack, readFrom}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, push, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                }{i, flush, hijack, push}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                        io.ReaderFrom
                }{i, flush, hijack, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Pusher
                        io.ReaderFrom
                }{i, flush, push, readFrom}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, hijack, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                }{i, closeNotifier, flush, hijack, push}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                        io.ReaderFrom
                }{i, closeNotifier, flush, hijack, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, flush, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, hijack, push, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, flush, hijack, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, flush, hijack, push, readFrom}</span>

        default:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                }{i}</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package http

import (
        "time"

        "go.opentelemetry.io/otel/trace"

        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

func NewMockServer() *Server <span class="cov8" title="1">{
        config := &amp;Config{
                Port:                  "9898",
                ServerShutdownTimeout: 5 * time.Second,
                HttpServerTimeout:     30 * time.Second,
                BackendURL:            []string{},
                ConfigPath:            "/config",
                DataPath:              "/data",
                HttpClientTimeout:     30 * time.Second,
                UIColor:               "blue",
                UIPath:                ".ui",
                UIMessage:             "Greetings",
                Hostname:              "localhost",
        }

        logger, _ := zap.NewDevelopment()

        return &amp;Server{
                router: mux.NewRouter(),
                logger: logger,
                config: config,
                tracer: trace.NewNoopTracerProvider().Tracer("mock"),
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package http

import (
        "net/http"
        "os"
)

// Panic godoc
// @Summary Panic
// @Description crashes the process with exit code 255
// @Tags HTTP API
// @Router /panic [get]
func (s *Server) panicHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.logger.Info("Panic command received")
        os.Exit(255)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"
        _ "net/http/pprof"
        "os"
        "path"
        "strings"
        "sync/atomic"
        "time"

        "github.com/gomodule/redigo/redis"
        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        _ "github.com/stefanprodan/podinfo/pkg/api/http/docs"
        "github.com/stefanprodan/podinfo/pkg/fscache"
        httpSwagger "github.com/swaggo/http-swagger"
        "github.com/swaggo/swag"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
        "golang.org/x/net/http2/h2c"
)

// @title Podinfo API
// @version 2.0
// @description Go microservice template for Kubernetes.

// @contact.name Source Code
// @contact.url https://github.com/stefanprodan/podinfo

// @license.name MIT License
// @license.url https://github.com/stefanprodan/podinfo/blob/master/LICENSE

// @BasePath /
// @schemes http https

var (
        healthy int32
        ready   int32
        watcher *fscache.Watcher
)

type Config struct {
        HttpClientTimeout     time.Duration `mapstructure:"http-client-timeout"`
        HttpServerTimeout     time.Duration `mapstructure:"http-server-timeout"`
        ServerShutdownTimeout time.Duration `mapstructure:"server-shutdown-timeout"`
        BackendURL            []string      `mapstructure:"backend-url"`
        UILogo                string        `mapstructure:"ui-logo"`
        UIMessage             string        `mapstructure:"ui-message"`
        UIColor               string        `mapstructure:"ui-color"`
        UIPath                string        `mapstructure:"ui-path"`
        DataPath              string        `mapstructure:"data-path"`
        ConfigPath            string        `mapstructure:"config-path"`
        CertPath              string        `mapstructure:"cert-path"`
        Host                  string        `mapstructure:"host"`
        Port                  string        `mapstructure:"port"`
        SecurePort            string        `mapstructure:"secure-port"`
        PortMetrics           int           `mapstructure:"port-metrics"`
        Hostname              string        `mapstructure:"hostname"`
        H2C                   bool          `mapstructure:"h2c"`
        RandomDelay           bool          `mapstructure:"random-delay"`
        RandomDelayUnit       string        `mapstructure:"random-delay-unit"`
        RandomDelayMin        int           `mapstructure:"random-delay-min"`
        RandomDelayMax        int           `mapstructure:"random-delay-max"`
        RandomError           bool          `mapstructure:"random-error"`
        Unhealthy             bool          `mapstructure:"unhealthy"`
        Unready               bool          `mapstructure:"unready"`
        JWTSecret             string        `mapstructure:"jwt-secret"`
        CacheServer           string        `mapstructure:"cache-server"`
}

type Server struct {
        router         *mux.Router
        logger         *zap.Logger
        config         *Config
        pool           *redis.Pool
        handler        http.Handler
        tracer         trace.Tracer
        tracerProvider *sdktrace.TracerProvider
}

func NewServer(config *Config, logger *zap.Logger) (*Server, error) <span class="cov0" title="0">{
        srv := &amp;Server{
                router: mux.NewRouter(),
                logger: logger,
                config: config,
        }

        return srv, nil
}</span>

func (s *Server) registerHandlers() <span class="cov0" title="0">{
        s.router.Handle("/metrics", promhttp.Handler())
        s.router.PathPrefix("/debug/pprof/").Handler(http.DefaultServeMux)
        s.router.HandleFunc("/", s.indexHandler).HeadersRegexp("User-Agent", "^Mozilla.*").Methods("GET")
        s.router.HandleFunc("/", s.infoHandler).Methods("GET")
        s.router.HandleFunc("/version", s.versionHandler).Methods("GET")
        s.router.HandleFunc("/echo", s.echoHandler)
        s.router.PathPrefix("/echo/").HandlerFunc(s.echoHandler)
        s.router.HandleFunc("/env", s.envHandler).Methods("GET", "POST")
        s.router.HandleFunc("/headers", s.echoHeadersHandler).Methods("GET", "POST")
        s.router.HandleFunc("/delay/{wait:[0-9]+}", s.delayHandler).Methods("GET").Name("delay")
        s.router.HandleFunc("/jobs/{id}/cancel", s.cancelJobHandler).Methods("POST").Name("cancelJob")
        s.router.HandleFunc("/jobs", s.listJobsHandler).Methods("GET").Name("listJobs")
        s.router.HandleFunc("/jobs/{id}", s.getJobHandler).Methods("GET").Name("getJob")
        s.router.HandleFunc("/healthz", s.healthzHandler).Methods("GET")
        s.router.HandleFunc("/readyz", s.readyzHandler).Methods("GET")
        s.router.HandleFunc("/readyz/enable", s.enableReadyHandler).Methods("POST")
        s.router.HandleFunc("/readyz/disable", s.disableReadyHandler).Methods("POST")
        s.router.HandleFunc("/panic", s.panicHandler).Methods("GET")
        s.router.HandleFunc("/status/{code:[0-9]+}", s.statusHandler).Methods("GET", "POST", "PUT").Name("status")
        s.router.HandleFunc("/store", s.storeWriteHandler).Methods("POST", "PUT")
        s.router.HandleFunc("/store/{hash}", s.storeReadHandler).Methods("GET").Name("store")
        s.router.HandleFunc("/cache/{key}", s.cacheWriteHandler).Methods("POST", "PUT")
        s.router.HandleFunc("/cache/{key}", s.cacheDeleteHandler).Methods("DELETE")
        s.router.HandleFunc("/cache/{key}", s.cacheReadHandler).Methods("GET").Name("cache")
        s.router.HandleFunc("/configs", s.configReadHandler).Methods("GET")
        s.router.HandleFunc("/token", s.tokenGenerateHandler).Methods("POST")
        s.router.HandleFunc("/token/validate", s.tokenValidateHandler).Methods("GET")
        s.router.HandleFunc("/api/info", s.infoHandler).Methods("GET")
        s.router.HandleFunc("/api/echo", s.echoHandler)
        s.router.PathPrefix("/api/echo/").HandlerFunc(s.echoHandler)
        s.router.HandleFunc("/ws/echo", s.echoWsHandler)
        s.router.HandleFunc("/chunked", s.chunkedHandler)
        s.router.HandleFunc("/chunked/{wait:[0-9]+}", s.chunkedHandler)
        s.router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
        ))
        s.router.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                doc, err := swag.ReadDoc()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("swagger error", zap.Error(err), zap.String("path", "/swagger.json"))
                }</span>
                <span class="cov0" title="0">w.Write([]byte(doc))</span>
        })
}

func (s *Server) registerMiddlewares() <span class="cov0" title="0">{
        prom := NewPrometheusMiddleware()
        s.router.Use(prom.Handler)
        otel := NewOpenTelemetryMiddleware()
        s.router.Use(otel)
        httpLogger := NewLoggingMiddleware(s.logger)
        s.router.Use(httpLogger.Handler)
        s.router.Use(versionMiddleware)
        if s.config.RandomDelay </span><span class="cov0" title="0">{
                randomDelayer := NewRandomDelayMiddleware(s.config.RandomDelayMin, s.config.RandomDelayMax, s.config.RandomDelayUnit)
                s.router.Use(randomDelayer.Handler)
        }</span>
        <span class="cov0" title="0">if s.config.RandomError </span><span class="cov0" title="0">{
                s.router.Use(randomErrorMiddleware)
        }</span>
}

func (s *Server) ListenAndServe() (*http.Server, *http.Server, *int32, *int32) <span class="cov0" title="0">{
        ctx := context.Background()

        go s.startMetricsServer()

        s.initTracer(ctx)
        s.registerHandlers()
        s.registerMiddlewares()

        if s.config.H2C </span><span class="cov0" title="0">{
                s.handler = h2c.NewHandler(s.router, &amp;http2.Server{})
        }</span> else<span class="cov0" title="0"> {
                s.handler = s.router
        }</span>

        //s.printRoutes()

        // load configs in memory and start watching for changes in the config dir
        <span class="cov0" title="0">if stat, err := os.Stat(s.config.ConfigPath); err == nil &amp;&amp; stat.IsDir() </span><span class="cov0" title="0">{
                var err error
                watcher, err = fscache.NewWatch(s.config.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("config watch error", zap.Error(err), zap.String("path", s.config.ConfigPath))
                }</span> else<span class="cov0" title="0"> {
                        watcher.Watch()
                }</span>
        }

        // start redis connection pool
        <span class="cov0" title="0">ticker := time.NewTicker(30 * time.Second)
        s.startCachePool(ticker)

        // create the http server
        srv := s.startServer()

        // create the secure server
        secureSrv := s.startSecureServer()

        // signal Kubernetes the server is ready to receive traffic
        if !s.config.Unhealthy </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;healthy, 1)
        }</span>
        <span class="cov0" title="0">if !s.config.Unready </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;ready, 1)
        }</span>

        <span class="cov0" title="0">return srv, secureSrv, &amp;healthy, &amp;ready</span>
}

func (s *Server) startServer() *http.Server <span class="cov0" title="0">{

        // determine if the port is specified
        if s.config.Port == "0" </span><span class="cov0" title="0">{

                // move on immediately
                return nil
        }</span>

        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         s.config.Host + ":" + s.config.Port,
                WriteTimeout: s.config.HttpServerTimeout,
                ReadTimeout:  s.config.HttpServerTimeout,
                IdleTimeout:  2 * s.config.HttpServerTimeout,
                Handler:      s.handler,
        }

        // start the server in the background
        go func() </span><span class="cov0" title="0">{
                s.logger.Info("Starting HTTP Server.", zap.String("addr", srv.Addr))
                if err := srv.ListenAndServe(); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Fatal("HTTP server crashed", zap.Error(err))
                }</span>
        }()

        // return the server and routine
        <span class="cov0" title="0">return srv</span>
}

func (s *Server) startSecureServer() *http.Server <span class="cov0" title="0">{

        // determine if the port is specified
        if s.config.SecurePort == "0" </span><span class="cov0" title="0">{

                // move on immediately
                return nil
        }</span>

        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         s.config.Host + ":" + s.config.SecurePort,
                WriteTimeout: s.config.HttpServerTimeout,
                ReadTimeout:  s.config.HttpServerTimeout,
                IdleTimeout:  2 * s.config.HttpServerTimeout,
                Handler:      s.handler,
        }

        cert := path.Join(s.config.CertPath, "tls.crt")
        key := path.Join(s.config.CertPath, "tls.key")

        // start the server in the background
        go func() </span><span class="cov0" title="0">{
                s.logger.Info("Starting HTTPS Server.", zap.String("addr", srv.Addr))
                if err := srv.ListenAndServeTLS(cert, key); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Fatal("HTTPS server crashed", zap.Error(err))
                }</span>
        }()

        // return the server
        <span class="cov0" title="0">return srv</span>
}

func (s *Server) startMetricsServer() <span class="cov0" title="0">{
        if s.config.PortMetrics &gt; 0 </span><span class="cov0" title="0">{
                mux := http.DefaultServeMux
                mux.Handle("/metrics", promhttp.Handler())
                mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        w.Write([]byte("OK"))
                }</span>)

                <span class="cov0" title="0">srv := &amp;http.Server{
                        Addr:    fmt.Sprintf(":%v", s.config.PortMetrics),
                        Handler: mux,
                }

                srv.ListenAndServe()</span>
        }
}

func (s *Server) printRoutes() <span class="cov0" title="0">{
        s.router.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error </span><span class="cov0" title="0">{
                pathTemplate, err := route.GetPathTemplate()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("ROUTE:", pathTemplate)
                }</span>
                <span class="cov0" title="0">pathRegexp, err := route.GetPathRegexp()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Path regexp:", pathRegexp)
                }</span>
                <span class="cov0" title="0">queriesTemplates, err := route.GetQueriesTemplates()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Queries templates:", strings.Join(queriesTemplates, ","))
                }</span>
                <span class="cov0" title="0">queriesRegexps, err := route.GetQueriesRegexp()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Queries regexps:", strings.Join(queriesRegexps, ","))
                }</span>
                <span class="cov0" title="0">methods, err := route.GetMethods()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Methods:", strings.Join(methods, ","))
                }</span>
                <span class="cov0" title="0">fmt.Println()
                return nil</span>
        })
}

type ArrayResponse []string
type MapResponse map[string]string
</pre>
		
		<pre class="file" id="file52" style="display: none">package http

import (
        "net/http"

        "strconv"

        "github.com/gorilla/mux"
)

// Status godoc
// @Summary Status code
// @Description sets the response status code to the specified code
// @Tags HTTP API
// @Accept json
// @Produce json
// @Param code path int true "status code to return"
// @Router /status/{code} [get]
// @Success 200 {object} http.MapResponse
func (s *Server) statusHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, span := s.tracer.Start(r.Context(), "statusHandler")
        defer span.End()

        vars := mux.Vars(r)

        code, err := strconv.Atoi(vars["code"])
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">s.JSONResponseCode(w, r, map[string]int{"status": code}, code)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package http

import (
        "crypto/sha1"
        "encoding/hex"
        "io"
        "net/http"
        "os"
        "path"

        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

// Store godoc
// @Summary Upload file
// @Description writes the posted content to disk at /data/hash and returns the SHA1 hash of the content
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /store [post]
// @Success 200 {object} http.MapResponse
func (s *Server) storeWriteHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "storeWriteHandler")
        defer span.End()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "reading the request body failed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hash := hash(string(body))
        err = os.WriteFile(path.Join(s.config.DataPath, hash), body, 0644)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("writing file failed", zap.Error(err), zap.String("file", path.Join(s.config.DataPath, hash)))
                s.ErrorResponse(w, r, span, "writing file failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">s.JSONResponseCode(w, r, map[string]string{"hash": hash}, http.StatusAccepted)</span>
}

// Store godoc
// @Summary Download file
// @Description returns the content of the file /data/hash if exists
// @Tags HTTP API
// @Accept json
// @Produce plain
// @Param hash path string true "hash value"
// @Router /store/{hash} [get]
// @Success 200 {string} string "file"
func (s *Server) storeReadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "storeReadHandler")
        defer span.End()

        hash := mux.Vars(r)["hash"]
        content, err := os.ReadFile(path.Join(s.config.DataPath, hash))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("reading file failed", zap.Error(err), zap.String("file", path.Join(s.config.DataPath, hash)))
                s.ErrorResponse(w, r, span, "reading file failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusAccepted)
        w.Write([]byte(content))</span>
}

func hash(input string) string <span class="cov0" title="0">{
        h := sha1.New()
        h.Write([]byte(input))
        return hex.EncodeToString(h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package http

import (
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "go.uber.org/zap"
)

type jwtCustomClaims struct {
        Name string `json:"name"`
        jwt.StandardClaims
}

// Token godoc
// @Summary Generate JWT token
// @Description issues a JWT token valid for one minute
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /token [post]
// @Success 200 {object} http.TokenResponse
func (s *Server) tokenGenerateHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, span := s.tracer.Start(r.Context(), "tokenGenerateHandler")
        defer span.End()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("reading the request body failed", zap.Error(err))
                s.ErrorResponse(w, r, span, "invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        user := "anonymous"
        if len(body) &gt; 0 </span><span class="cov8" title="1">{
                user = string(body)
        }</span>

        <span class="cov8" title="1">expiresAt := time.Now().Add(time.Minute * 1)
        claims := &amp;jwtCustomClaims{
                user,
                jwt.StandardClaims{
                        Issuer:    "podinfo",
                        ExpiresAt: expiresAt.Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        t, err := token.SignedString([]byte(s.config.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var result = TokenResponse{
                Token:     t,
                ExpiresAt: time.Unix(claims.StandardClaims.ExpiresAt, 0),
        }

        s.JSONResponse(w, r, result)</span>
}

// TokenValidate godoc
// @Summary Validate JWT token
// @Description validates the JWT token
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /token/validate [post]
// @Success 200 {object} http.TokenValidationResponse
// @Failure 401 {string} string "Unauthorized"
// Get: JWT=$(curl -s -d 'test' localhost:9898/token | jq -r .token)
// Post: curl -H "Authorization: Bearer ${JWT}" localhost:9898/token/validate
func (s *Server) tokenValidateHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, span := s.tracer.Start(r.Context(), "tokenValidateHandler")
        defer span.End()

        authorizationHeader := r.Header.Get("authorization")
        if authorizationHeader == "" </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "authorization bearer header required", http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">bearerToken := strings.Split(authorizationHeader, " ")
        if len(bearerToken) != 2 || strings.ToLower(bearerToken[0]) != "bearer" </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, "authorization bearer header required", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">claims := jwtCustomClaims{}
        token, err := jwt.ParseWithClaims(bearerToken[1], &amp;claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid signing method")
                }</span>
                <span class="cov0" title="0">return []byte(s.config.JWTSecret), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, span, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                if claims.StandardClaims.Issuer != "podinfo" </span><span class="cov0" title="0">{
                        s.ErrorResponse(w, r, span, "invalid issuer", http.StatusUnauthorized)
                }</span> else<span class="cov0" title="0"> {
                        var result = TokenValidationResponse{
                                TokenName: claims.Name,
                                ExpiresAt: time.Unix(claims.StandardClaims.ExpiresAt, 0),
                        }
                        s.JSONResponse(w, r, result)
                }</span>
        } else<span class="cov0" title="0"> {
                s.ErrorResponse(w, r, span, "Invalid authorization token", http.StatusUnauthorized)
        }</span>
}

type TokenResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
}

type TokenValidationResponse struct {
        TokenName string    `json:"token_name"`
        ExpiresAt time.Time `json:"expires_at"`
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package http

import (
        "context"

        "github.com/gorilla/mux"
        "github.com/spf13/viper"
        "github.com/stefanprodan/podinfo/pkg/version"
        "go.opentelemetry.io/contrib/instrumentation/github.com/gorilla/mux/otelmux"
        "go.opentelemetry.io/contrib/propagators/aws/xray"
        "go.opentelemetry.io/contrib/propagators/b3"
        "go.opentelemetry.io/contrib/propagators/jaeger"
        "go.opentelemetry.io/contrib/propagators/ot"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.7.0"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
)

const (
        instrumentationName = "github.com/stefanprodan/podinfo/pkg/api"
)

func (s *Server) initTracer(ctx context.Context) <span class="cov0" title="0">{
        if viper.GetString("otel-service-name") == "" </span><span class="cov0" title="0">{
                nop := trace.NewNoopTracerProvider()
                s.tracer = nop.Tracer(viper.GetString("otel-service-name"))
                return
        }</span>

        <span class="cov0" title="0">client := otlptracegrpc.NewClient()
        exporter, err := otlptrace.New(ctx, client)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("creating OTLP trace exporter", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.tracerProvider = sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(viper.GetString("otel-service-name")),
                        semconv.ServiceVersionKey.String(version.VERSION),
                )),
        )

        otel.SetTracerProvider(s.tracerProvider)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
                b3.New(),
                &amp;jaeger.Jaeger{},
                &amp;ot.OT{},
                &amp;xray.Propagator{},
        ))

        s.tracer = s.tracerProvider.Tracer(
                instrumentationName,
                trace.WithInstrumentationVersion(version.VERSION),
                trace.WithSchemaURL(semconv.SchemaURL),
        )</span>
}

func NewOpenTelemetryMiddleware() mux.MiddlewareFunc <span class="cov0" title="0">{
        return otelmux.Middleware(viper.GetString("otel-service-name"))
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package http

import (
        "net/http"

        "github.com/stefanprodan/podinfo/pkg/version"
)

// Version godoc
// @Summary Version
// @Description returns podinfo version and git commit hash
// @Tags HTTP API
// @Produce json
// @Router /version [get]
// @Success 200 {object} http.MapResponse
func (s *Server) versionHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        result := map[string]string{
                "version": version.VERSION,
                "commit":  version.REVISION,
        }
        s.JSONResponse(w, r, result)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package fscache

import (
        "errors"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/fsnotify/fsnotify"
)

type Watcher struct {
        dir       string
        fswatcher *fsnotify.Watcher
        Cache     *sync.Map
}

// NewWatch creates a directory watcher and
// updates the cache when any file changes in that dir
func NewWatch(dir string) (*Watcher, error) <span class="cov8" title="1">{
        if len(dir) &lt; 1 </span><span class="cov8" title="1">{
                return nil, errors.New("directory is empty")
        }</span>

        <span class="cov8" title="1">fw, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">w := &amp;Watcher{
                dir:       dir,
                fswatcher: fw,
                Cache:     new(sync.Map),
        }

        log.Printf("fscache start watcher for %s", w.dir)
        err = w.fswatcher.Add(w.dir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // initial read
        <span class="cov8" title="1">err = w.updateCache()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return w, nil</span>
}

// Watch watches for when kubelet updates the volume mount content
func (w *Watcher) Watch() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        // it can take up to a 2 minutes for kubelet to recreate the ..data symlink
                        case event := &lt;-w.fswatcher.Events:<span class="cov8" title="1">
                                if event.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov8" title="1">{
                                        if filepath.Base(event.Name) == "..data" </span><span class="cov0" title="0">{
                                                err := w.updateCache()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Printf("fscache update error %v", err)
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Printf("fscache reload %s", w.dir)
                                                }</span>
                                        }
                                }
                        case err := &lt;-w.fswatcher.Errors:<span class="cov0" title="0">
                                log.Printf("fswatcher %s error %v", w.dir, err)</span>
                        }
                }
        }()
}

// updateCache reads files content and loads them into the cache
func (w *Watcher) updateCache() error <span class="cov8" title="1">{
        fileMap := make(map[string]string)
        files, err := os.ReadDir(w.dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // read files ignoring symlinks and sub directories
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                name := filepath.Base(file.Name())
                if !file.IsDir() &amp;&amp; !strings.Contains(name, "..") </span><span class="cov8" title="1">{
                        b, err := os.ReadFile(filepath.Join(w.dir, file.Name()))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">fileMap[name] = string(b)</span>
                }
        }

        // remove deleted files from cache
        <span class="cov8" title="1">w.Cache.Range(func(key interface{}, value interface{}) bool </span><span class="cov8" title="1">{
                _, ok := fileMap[key.(string)]
                if !ok </span><span class="cov8" title="1">{
                        w.Cache.Delete(key)
                }</span>
                <span class="cov8" title="1">return true</span>
        })

        // sync cache
        <span class="cov8" title="1">for k, v := range fileMap </span><span class="cov8" title="1">{
                w.Cache.Store(k, v)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package signals

import (
        "context"
        "net/http"
        "sync/atomic"
        "time"

        "github.com/gomodule/redigo/redis"
        "github.com/spf13/viper"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

type Shutdown struct {
        logger                *zap.Logger
        pool                  *redis.Pool
        tracerProvider        *sdktrace.TracerProvider
        serverShutdownTimeout time.Duration
}

func NewShutdown(serverShutdownTimeout time.Duration, logger *zap.Logger) (*Shutdown, error) <span class="cov0" title="0">{
        srv := &amp;Shutdown{
                logger:                logger,
                serverShutdownTimeout: serverShutdownTimeout,
        }

        return srv, nil
}</span>

func (s *Shutdown) Graceful(stopCh &lt;-chan struct{}, httpServer *http.Server, httpsServer *http.Server, grpcServer *grpc.Server, healthy *int32, ready *int32) <span class="cov0" title="0">{
        ctx := context.Background()

        // wait for SIGTERM or SIGINT
        &lt;-stopCh
        ctx, cancel := context.WithTimeout(ctx, s.serverShutdownTimeout)
        defer cancel()

        // all calls to /healthz and /readyz will fail from now on
        atomic.StoreInt32(healthy, 0)
        atomic.StoreInt32(ready, 0)

        // close cache pool
        if s.pool != nil </span><span class="cov0" title="0">{
                _ = s.pool.Close()
        }</span>

        <span class="cov0" title="0">s.logger.Info("Shutting down HTTP/HTTPS server", zap.Duration("timeout", s.serverShutdownTimeout))

        // There could be a period where a terminating pod may still receive requests. Implementing a brief wait can mitigate this.
        // See: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
        // the readiness check interval must be lower than the timeout
        if viper.GetString("level") != "debug" </span><span class="cov0" title="0">{
                time.Sleep(3 * time.Second)
        }</span>

        // stop OpenTelemetry tracer provider
        <span class="cov0" title="0">if s.tracerProvider != nil </span><span class="cov0" title="0">{
                if err := s.tracerProvider.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("stopping tracer provider", zap.Error(err))
                }</span>
        }

        // determine if the GRPC was started
        <span class="cov0" title="0">if grpcServer != nil </span><span class="cov0" title="0">{
                s.logger.Info("Shutting down GRPC server", zap.Duration("timeout", s.serverShutdownTimeout))
                grpcServer.GracefulStop()
        }</span>

        // determine if the http server was started
        <span class="cov0" title="0">if httpServer != nil </span><span class="cov0" title="0">{
                if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("HTTP server graceful shutdown failed", zap.Error(err))
                }</span>
        }

        // determine if the secure server was started
        <span class="cov0" title="0">if httpsServer != nil </span><span class="cov0" title="0">{
                if err := httpsServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("HTTPS server graceful shutdown failed", zap.Error(err))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package signals

import (
        "os"
        "os/signal"
)

var onlyOneSignalHandler = make(chan struct{})

// SetupSignalHandler registered for SIGTERM and SIGINT. A stop channel is returned
// which is closed on one of these signals. If a second signal is caught, the program
// is terminated with exit code 1.
func SetupSignalHandler() (stopCh &lt;-chan struct{}) <span class="cov8" title="1">{
        close(onlyOneSignalHandler) // panics when called twice

        stop := make(chan struct{})
        c := make(chan os.Signal, 2)
        signal.Notify(c, shutdownSignals...)
        go func() </span><span class="cov8" title="1">{
                &lt;-c
                close(stop)
                &lt;-c
                os.Exit(1) // second signal. Exit directly.
        }</span>()

        <span class="cov8" title="1">return stop</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
